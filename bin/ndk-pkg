#!/bin/sh

#------------------------------------------------------------------------------
# Reference:   https://developer.android.google.cn/ndk/guides/other_build_systems
# requirement: Android NDK version must be r19 or newer.
#------------------------------------------------------------------------------

NDK_PKG_VERSION=0.1.0
NDK_PKG_HOME="$HOME/.ndk-pkg"
NDK_PKG_FORMULA_REPO_URL='https://github.com/leleliu008/ndk-pkg-formula.git'

DIR_FORMULA="$NDK_PKG_HOME/formula"
DIR_DOWNLOAD="$NDK_PKG_HOME/downloads"
DIR_BOTTLE="$NDK_PKG_HOME/bottles"
DIR_BACKUP="$NDK_PKG_HOME/backup"
DIR_PKG="$NDK_PKG_HOME/pkg"

TARGET_ABIS='armeabi-v7a arm64-v8a x86 x86_64'


#------------------------------------------------------------------------------

Color_Red='\033[0;31m'          # Red
Color_Green='\033[0;32m'        # Green
Color_Yellow='\033[0;33m'       # Yellow
Color_Blue='\033[0;34m'         # Blue
Color_Purple='\033[0;35m'       # Purple
Color_Off='\033[0m'             # Reset

msg() {
    printf "%b" "$*"
}

command -v echo > /dev/null || {
    echo() {
        msg "$@\n"
    }
}

info() {
    msg "${Color_Purple}[★] $@\n${Color_Off}"
}

success() {
    msg "${Color_Green}[✔] $@\n${Color_Off}"
}

warn() {
    msg "${Color_Yellow}🔥 $@\n${Color_Off}"
}

error() {
    msg "${Color_Red}[✘] $@\n${Color_Off}"
}

die() {
    msg "${Color_Red}[✘] $@\n${Color_Off}"
    exit 1
}

print_list() {
    for item in $@
    do
        echo "$item"
    done
}

nproc() {
    if command -v nproc > /dev/null ; then
        command nproc
    elif command -v sysctl > /dev/null ; then
        sysctl -n machdep.cpu.thread_count
    elif test -f /proc/cpuinfo ; then
        grep -c processor /proc/cpuinfo
    else
        echo 4
    fi
}

sed_in_place() {
    if command -v gsed > /dev/null ; then
        gsed -i "$1" "$2"
    elif command -v sed  > /dev/null ; then
        sed -i    "$1" "$2" 2> /dev/null || 
        sed -i "" "$1" "$2"
    else
        die "please install sed utility."
    fi
}

format_unix_timestamp() {
   date -jf "%s" "$1" "$2" 2> /dev/null ||
   date -d      "@$1" "$2"
}

getvalue() {
    echo "$1" | cut -d= -f2
}

is_exist_and_executable() {
    [ -f "$1" ] || die "$1 is not exist."
    [ -x "$1" ] || die "$1 is not executable."
}

is_sha256sum_match() {
    if command -v openssl > /dev/null ; then
        [ "$(openssl sha256 "$1" | awk '{print $2}')" = "$2" ]
    elif command -v sha256sum > /dev/null ; then
        [ "$(sha256sum "$1" | awk '{print $1}')" = "$2" ]
    else
        die "please install openssl or GNU CoreUtils."
    fi
}

is_package_available() {
    [ -z "$1" ] && die_from_package_is_not_provided
    [ -f "$DIR_FORMULA/$1.sh" ]
}

is_package_installed() {
    [ -z "$1" ] && die_from_package_is_not_provided
    [ -d "$DIR_PKG/$1" ] &&
    [ -f "$DIR_PKG/$1/installed" ]
}

is_package_outdated() {
    [ -z "$1" ] && die_from_package_is_not_provided
    [ -z "$2" ] || warn "outdated? command accept only one parameter."
    
    is_package_available "$1" || die_from_package_is_not_available "$1"
    is_package_installed "$1" || die_from_package_is_not_installed "$1"

    load_formula_of_a_package "$1"
    load_installed_info_of_a_package "$1"

    [ "$version" = "$installed_pkg_version" ] && return 1
    [ "$version" = $(printf "$version\n$installed_pkg_version" | sort --version-sort --reverse | head -n 1) ]
}

die_from_package_is_not_installed() {
    die "$1 is not installed."
}

die_from_package_is_not_available() {
    die "$1 is not available."
}

die_from_package_is_not_provided() {
    die "please provide a package name."
}

die_from_packages_is_not_provided() {
    die "please provide at least one package name."
}

die_from_sha256sum_mismatch() {
    die "sha256sum mismatch."
}

fetch_internal() {
    [ -d "$DIR_DOWNLOAD" ] || mkdir -p "$DIR_DOWNLOAD"
    cd "$DIR_DOWNLOAD" || exit 1
    
    if command -v curl > /dev/null ; then
        info "Downloding $url" &&
        curl -LO "$url" &&
        success "Downloaded $SRC_FILE_PATH"
    elif command -v wget > /dev/null ; then
        info "Downloding $url" &&
        wget "$url" &&
        success "Downloaded $SRC_FILE_PATH"
    else
        die "please install curl or wget."
    fi
}

fetch_if_needed() {
    SRC_FILE_NAME=$(basename "$url") && 
    SRC_FILE_NAME_EXT=$(echo "$SRC_FILE_NAME" | awk -F. '{print $NF}') && 
    SRC_FILE_PATH="$DIR_DOWNLOAD/$SRC_FILE_NAME"
        
    if [ -f "$SRC_FILE_PATH" ] ; then
        if is_sha256sum_match "$SRC_FILE_PATH" "$sha256" ; then
            success "$SRC_FILE_PATH is already downloaded."
        else
            rm "$SRC_FILE_PATH" && fetch_internal
        fi
    else
        fetch_internal
    fi
}

fetch_a_package() {
    load_formula_of_a_package "$1"
    fetch_if_needed
}

uncompress() {
    case "$2" in
        zip) unzip "$1";;
        xz|gz|bz2) tar xf "$1" --strip-components 1;;
        *) false;;
    esac
}

install_packages() {
    [ -z "$TARGET_PACKAGE_LIST" ] && die_from_packages_is_not_provided
    
    for toBeInstalledPkgName in $TARGET_PACKAGE_LIST
    do
        get_dependencies_of_a_package "$toBeInstalledPkgName"
    done

    for toBeInstalledPkgName in $(echo "$DEPENDENCIES $TARGET_PACKAGE_LIST")
    do
        is_package_installed "$toBeInstalledPkgName" &&
        success "$toBeInstalledPkgName is already installed." &&
        continue
        install_a_package "$toBeInstalledPkgName"
    done
}

install_a_package() {
    fetch_a_package "$1"
    
    is_sha256sum_match "$SRC_FILE_PATH" "$sha256" || die_from_sha256sum_mismatch
    
    [ -d "$DIR_PKG/$1" ] && rm -rf "$DIR_PKG/$1"
    
    DIR_SRC=$(mktemp -d) &&
    cd "$DIR_SRC" &&
    info "uncompressing $SRC_FILE_PATH" &&
    uncompress "$SRC_FILE_PATH" "$SRC_FILE_NAME_EXT" &&
    success "uncompressed in $DIR_SRC" &&
    install_a_package_for_all_target_abis "$1" &&
    install_a_package_success "$1" &&
    rm -rf "$DIR_SRC"
}

install_a_package_for_all_target_abis() {
    unset "build_$TIMESTAMP_UNIX"
    
    for TARGET_ABI in $(printf "$TARGET_ABIS")
    do
        make_env "$1" || die "build $1/$TARGET_ABI failed!"
        
        if command -v prepare > /dev/null ; then
            if eval test -z "$"build_$TIMESTAMP_UNIX ; then
                eval "build_$TIMESTAMP_UNIX='true'"
                prepare || die "build $1/$TARGET_ARCH failed!"
            fi
        fi
        
        build || die "build $1/$TARGET_ARCH failed!"
    done
}

install_a_package_success() {
    [ -d "$DIR_INSTALL_PACKAGE" ] || die "$1 build failed. installed nothing."
    
    cat > "$DIR_INSTALL_PACKAGE/installed" <<EOF
installed_time=$TIMESTAMP_UNIX
installed_pkg_version=$version
installed_ndk_version=$ANDROID_NDK_VERSION
installed_target_api=$TARGET_API
EOF
    
    success "$1 build success. in $DIR_INSTALL_PACKAGE directory."
    
    if command -v tree > /dev/null ; then
        tree -L 3 --dirsfirst "$DIR_INSTALL_PACKAGE"
    fi
}

tree_a_installed_package() {
    DIR_INSTALL_PACKAGE="$DIR_PKG/$1"
    [ -d "$DIR_INSTALL_PACKAGE" ] || die_from_package_is_not_installed "$1"
    shift
    command -v tree > /dev/null || die "please install tree utility."
    tree $@ --dirsfirst "$DIR_INSTALL_PACKAGE"
}

uninstall_packages() {
    [ -z "$1" ] && die_from_packages_is_not_provided
    
    for packageName in $@
    do
        uninstall_a_package "$packageName"
    done
}

uninstall_a_package() {
    [ -d "$DIR_PKG/$1" ] || die_from_package_is_not_installed "$1"
    info "uninstalling $1..." &&
    rm -rf "$DIR_PKG/$1" &&
    success "$1 uninstalled."
}

list_available_packages() {
    unset SILENT

    case $# in
        0)  ;;
        1)  if [ "$1" = '-q' ] ; then
                SILENT=true
            else
                die "list available command only accept -q argument."
            fi
            ;;
        *)  die "list available command only accept -q argument."
    esac

    [ -d "$DIR_FORMULA" ] || {
        if [ "$SILENT" = 'true' ] ; then
            update_formula_repository >/dev/null 2>&1
        else
            update_formula_repository
        fi
    }
    
    if [ "$SILENT" = 'true' ] ; then
        cd "$DIR_FORMULA" 2>/dev/null || exit 1
    else
        cd "$DIR_FORMULA" || exit 1
    fi

    for item in $(ls *.sh | sed 's/.sh//g')
    do
        echo "$item"
    done
}

list_installed_packages() {
    for packageName in $(cd "$DIR_PKG" 2>/dev/null || exit 1; ls)
    do
        if is_package_installed "$packageName" ; then
            echo "$packageName"
        fi
    done
}

list_outdated_packages() {
    for packageName in $(cd "$DIR_PKG" 2>/dev/null || exit 1; ls)
    do
        is_package_available "$packageName" || continue
        is_package_installed "$packageName" || continue
        if is_package_outdated "$packageName" ; then
            echo "$packageName"
        fi
    done
}

info_packages() {
    if [ -z "$1" ] ; then
        [ -d "$DIR_FORMULA" ] || update_formula_repository
        cd "$DIR_FORMULA" || exit 1
        unset INFO
        for item in *.sh
        do 
            [ -z "$INFO" ] || echo "-----------------------------------------------------------"; 
            info_a_package $(echo "$item" | sed 's/.sh//g')
            INFO=true
        done
    else
        unset INFO
        for packageName in $@
        do 
            [ -z "$INFO" ] || echo "-----------------------------------------------------------"; 
            info_a_package "$packageName"
            INFO=true
        done
    fi
}

info_a_package() {
    load_formula_of_a_package "$1"
     
    echo "name      : $1"
    echo "summary   : $summary"
    echo "homepage  : $homepage"
    echo "available : $version"
    
    [ -z "$dependencies" ] || {
        msg "depend_on :"
        unset DEPENDENCIES
        for dependencyPkgName in $(echo "$dependencies")
        do
            if [ -z "$DEPENDENCIES" ] ; then
                DEPENDENCIES=true
                msg " "
            else
                msg "            "
            fi

            if is_package_installed "$dependencyPkgName" ; then
                echo "$dependencyPkgName ${Color_Green}✔${Color_Off}"
            else
                echo "$dependencyPkgName ${Color_Red}✘${Color_Off}"
            fi
        done
    }
     
    if is_package_installed "$1" ; then
        load_installed_info_of_a_package "$1"
        echo "installed ${Color_Purple}==>${Color_Off} $(du -sh "$DIR_PKG/$1" | awk '{print $2, $1}')"
        echo "install_time: $(format_unix_timestamp $installed_time '+%Y/%m/%d %H:%M:%S')"
        echo "pkg_version : $installed_pkg_version"
        echo "ndk_version : $installed_ndk_version"
        echo "target_api  : $installed_target_api"
    else
        echo "installed : ${Color_Red}✘${Color_Off}"
    fi
}

load_formula_of_a_package() {
    is_package_available "$1" || die_from_package_is_not_available "$1"

    unset -f prepare
    unset -f build
    unset url
    unset sha256
    unset version
    unset summary
    unset homepage
    unset dependencies
    
    FORMULA_FILE_PATH="$DIR_FORMULA/$1.sh"
     
    . "$FORMULA_FILE_PATH" || die "$FORMULA_FILE_PATH is broken."
    
    [ -z "$summary" ]  && die "summary variable must be provided in $FORMULA_FILE_PATH"
    [ -z "$homepage" ] && die "homepage variable must be provided in $FORMULA_FILE_PATH"
    [ -z "$sha256" ]   && die "sha256 variable must be provided in $FORMULA_FILE_PATH"
    [ -z "$url" ]      && die "url variable must be provided in $FORMULA_FILE_PATH"
    [ -z "$version" ]  && version="$(basename "$url" | awk '{str = tolower($0); gsub(".tar.xz", "", str); gsub(".tar.gz", "", str); gsub(".tar.bz2", "", str); gsub(".tgz", "", str); gsub(".zip", "", str); print(str)}' | awk -F- '{print $NF}')"
    [ -z "$version" ]  && die "version can't be parsed in $FORMULA_FILE_PATH"
}

load_installed_info_of_a_package() {
    unset installed_time
    unset installed_pkg_version
    unset installed_ndk_version
    unset installed_target_api
    
    . "$DIR_PKG/$1/installed"
}

cat_formula_of_a_package() {
    [ -z "$1" ] && die_from_package_is_not_provided
    [ -z "$2" ] || warn "cat command accept only one parameter."
    
    is_package_available "$1" || die_from_package_is_not_available "$1"
    
    if command -v bat > /dev/null ; then
        bat "$DIR_FORMULA/$1.sh"
    else
        cat "$DIR_FORMULA/$1.sh"
        echo
        warn "if you want to have a better experience, I strongly recommend you install ${Color_Red}bat${Color_Off} on your os. For more details, see ${Color_Red}https://github.com/sharkdp/bat${Color_Off}"
    fi    
}

edit_formula_of_a_package() {
    [ -z "$1" ] && die_from_package_is_not_provided
    [ -z "$2" ] || warn "edit command accept only one parameter."
    
    is_package_available "$1" || die_from_package_is_not_available "$1"
   
    [ -z "$EDITOR" ] &&
    EDITOR=$(command -v vi) ||
    EDITOR=$(command -v vim) ||
    EDITOR=$(command -v nvim) ||
    EDITOR=$(command -v open) ||
    die "please config EDITOR environment." 

    "$EDITOR" "$DIR_FORMULA/$1.sh"
}

update_formula_repository() {
    info "Updating formula repository."

    if [ -d "$DIR_FORMULA" ] ; then
        if  git -C "$DIR_FORMULA" rev-parse 2> /dev/null ; then
            git -C "$DIR_FORMULA" pull
        else
            rm -rf "$DIR_FORMULA" &&
            git -C "$NDK_PKG_HOME" clone "$NDK_PKG_FORMULA_REPO_URL" formula
        fi
    else
        mkdir -p "$NDK_PKG_HOME" &&
        git -C "$NDK_PKG_HOME" clone "$NDK_PKG_FORMULA_REPO_URL" formula
    fi
    
    if [ $? -eq 0 ] ; then
        success "update formula repository success."
    else
        die "update formula repository failed."
    fi
}

upgrade_packages() {
    [ -z "$TARGET_PACKAGE_LIST" ] && TARGET_PACKAGE_LIST=$(list_outdated_packages)
    [ -z "$TARGET_PACKAGE_LIST" ] && return 0

    reinstall_packages
}

reinstall_packages() {
    [ -z "$TARGET_PACKAGE_LIST" ] && die_from_packages_is_not_provided
     
    for packageName in $TARGET_PACKAGE_LIST
    do
        is_package_available "$packageName" || die_from_package_is_not_available "$packageName"
        is_package_installed "$packageName" || die_from_package_is_not_installed "$packageName"
    done
    
    for packageName in $TARGET_PACKAGE_LIST
    do
        {
            [ -d "$DIR_BACKUP" ] || mkdir -p "$DIR_BACKUP"
        } &&
        mv "$DIR_PKG/$packageName" "$DIR_BACKUP/$packageName" &&
        install_a_package "$packageName" &&
        rm -rf "$DIR_BACKUP/$packageName"
    done
}

cleanup() {
    success "Done."
}

search_packages() {
    [ -z "$1" ] && die "please specify a keyword."
    [ -d "$DIR_FORMULA" ] || update_formula_repository
        
    for item in $(cd "$DIR_FORMULA" || exit 1; ls -1 *.sh | sed 's/.sh//g')
    do
        echo "$item" | grep "$*"
    done
}

open_homepage_of_a_package() {
    if [ -z "$1" ] ; then
        homepage="https://github.com/leleliu008/ndk-pkg"
    else
        load_formula_of_a_package "$1"
    fi
    
    if command -v open > /dev/null ; then
	    open "$homepage"
    else
	    echo "$homepage"
    fi
}

print_prefix_of_a_package() {
    if [ -z "$1" ] ; then
        echo "$NDK_PKG_HOME"
    else
        is_package_installed "$1" || die_from_package_is_not_installed "$1"
        echo "$DIR_PKG/$1"
    fi
}

logs_a_package() {
    [ -z "$1" ] && die_from_package_is_not_provided
    is_package_installed "$1" || die_from_package_is_not_installed "$1"
    
    FILE_PATH_LOGS="$DIR_PKG/$1/logs"
    
    if [ -f "$FILE_PATH_LOGS" ] ; then
        success "$FILE_PATH_LOGS ===>"
        cat "$FILE_PATH_LOGS"
    else
        warn "no logs."
    fi
}

pack_a_package() {
    [ -z "$1" ] && die_from_package_is_not_provided
    is_package_installed "$1" || die_from_package_is_not_installed "$1"
    
    [ -d "$DIR_BOTTLE" ] || mkdir -p "$DIR_BOTTLE"
    
    if command -v tar > /dev/null ; then
        if command -v gzip > /dev/null ; then
            FILE_PATH_BOTTLE="$DIR_BOTTLE/$1-bottle.tar.gz"
            info "packing $1..." &&
            tar zvcf "$FILE_PATH_BOTTLE" -C "$DIR_PKG" "$1"
        elif command -v xz > /dev/null ; then
            FILE_PATH_BOTTLE="$DIR_BOTTLE/$1-bottle.tar.xz"
            info "packing $1..." &&
            tar zvcf "$FILE_PATH_BOTTLE" -C "$DIR_PKG" "$1"
        elif command -v bzip2 > /dev/null ; then
            FILE_PATH_BOTTLE="$DIR_BOTTLE/$1-bottle.tar.bz2"
            info "packing $1..." &&
            tar zvcf "$FILE_PATH_BOTTLE" -C "$DIR_PKG" "$1"
        fi
    elif command -v zip > /dev/null ; then
        FILE_PATH_BOTTLE="$DIR_BOTTLE/$1-bottle.zip"
        cd "$DIR_PKG" &&
        info "packing $1..." &&
        zip -r "$FILE_PATH_BOTTLE" "$1"
    fi
    
    if [ $? -eq 0 ] ; then
        success "packed success. $FILE_PATH_BOTTLE"
    else
        die "pack $1 failed."
    fi
}

get_direct_dependencies_of_a_package() {
    grep '^dependencies=".*"' "$DIR_FORMULA/$1.sh" | sed 's/dependencies="\(.*\)"/\1/'
}

get_dependencies_of_a_package() {
    for dependencyPkgName in $(get_direct_dependencies_of_a_package "$1")
    do
        is_package_available "$dependencyPkgName" || die_from_package_is_not_available "$dependencyPkgName"
        DEPENDENCIES="$dependencyPkgName $DEPENDENCIES"
        get_dependencies_of_a_package "$dependencyPkgName"
    done
}


########################################################################

get_ndk_version_via_awk() {
    awk -F= '/Pkg.Revision/{print(substr($2, 2))}' "$ANDROID_NDK_HOME/source.properties"
}

get_ndk_version_via_cut() {
    grep "Pkg.Revision" "$ANDROID_NDK_HOME/source.properties" | cut -d " " -f3
}

get_ndk_version_via_sed() {
    grep "Pkg.Revision" "$ANDROID_NDK_HOME/source.properties" | "$SED" 's/Pkg\.Revision = \(.*\).*/\1/'
}

get_ndk_version_via_ruby() {
    ruby <<EOF
File.open(ENV['ANDROID_NDK_HOME'] + '/source.properties', 'r') {|f|
  f.each_line {|lineText|
    if (lineText =~ /Pkg.Revision =.*/)
        puts lineText.gsub('Pkg.Revision = ', '')
    end
  }
  f.close
}
EOF
}

get_ndk_version_via_perl() {
    perl << EOF
open(DATA, "<$ANDROID_NDK_HOME/source.properties") or die "$ANDROID_NDK_HOME/source.properties文件无法打开, $!";
while(<DATA>) {
    if ("\$_" =~ m/Pkg.Revision/) {
        print substr("\$_", 15);
    }
}
EOF
}

get_ndk_version_via_python() {
    "$PYTHON" << EOF
import re;
file = open("$ANDROID_NDK_HOME/source.properties");
lines = file.readlines();
for line in lines:
    if -1 != line.find("Pkg.Revision"):
        print(re.findall("[0-9]{1,2}\.[0-9]{1,2}\.[0-9]{1,7}", line)[0]);
EOF
}

get_ndk_version_via_nodejs() {
    node << EOF
const fs = require('fs');

const buffer = fs.readFileSync("$ANDROID_NDK_HOME/source.properties");
if (buffer instanceof Error) {
    console.log(buffer);
    process.exit(1);
}

const text = buffer.toString();
const lines = text.split('\n');
lines.forEach((line, index, lines) => {
    const matched = line.match(/\d+\.\d+\.\d+/);
    if (matched) {
        console.log(matched[0]);
    }
});
EOF
}

get_ndk_version() {
    command -v cut  > /dev/null && get_ndk_version_via_cut    && return 0 
    command -v awk  > /dev/null && get_ndk_version_via_awk    && return 0
    command -v ruby > /dev/null && get_ndk_version_via_ruby   && return 0 
    command -v perl > /dev/null && get_ndk_version_via_perl   && return 0    
    command -v node > /dev/null && get_ndk_version_via_nodejs && return 0
    
    SED=$(command -v gsed) ||
    SED=$(command -v  sed)
    [ -z "$SED" ] || get_ndk_version_via_sed && return 0
     
    PYTHON=$(command -v python3) ||
    PYTHON=$(command -v python)  ||
    PYTHON=$(command -v python2) 
    [ -z "$PYTHON" ] || get_ndk_version_via_python && return 0
}

get_ndk_version_major() {
    command -v cut > /dev/null && printf "$ANDROID_NDK_VERSION" | cut -d. -f1          && return 0
    command -v awk > /dev/null && printf "$ANDROID_NDK_VERSION" | awk -F. '{print $1}' && return 0
    command -v sed > /dev/null && printf "$ANDROID_NDK_VERSION" | sed 's/\..*//g'      && return 0
    echo 0
}

check_ANDROID_NDK_HOME() {
    [ -z "$ANDROID_ROOT" ] || export ANDROID_NDK_HOME="$ANDROID_ROOT"
    [ -z "$ANDROID_NDK_HOME" ] && die "please set ANDROID_NDK_HOME environment variable, then try again!"
    [ -d "$ANDROID_NDK_HOME" ] || die "ANDROID_NDK_HOME=$ANDROID_NDK_HOME is not a valid directory!"
}

check_ANDROID_NDK_VERSION() {
    ANDROID_NDK_VERSION="$(get_ndk_version)"
    [ "$(get_ndk_version_major)" -lt 19 ] && die "your ndk version is $ANDROID_NDK_VERSION, please update to r19 or newer."
}

list_target_abis() {
    print_list "$TARGET_ABIS"
}

list_target_apis() {
    print_list 21 22 23 34 25 26 27 28 29
}

#选择某个目标ABI，比如armeabi-v7a，可以通过ndk-pkg list target-abis命令列出支持的目标的名称
select_target_abi_if_needed() {
    [ -z "$TARGET_ABI" ] && {
        info "below is the supported TARGET_ABIS:"
        list_target_abis
        info "please input your select TARGET_ABI:"
        read -r TARGET_ABI
        select_target_abi_if_needed
    }
}

#选择某个目标API，比如21、22、23、34、25、26、27、28、29，可以通过ndk-pkg list target-apis命令列出支持的API level
select_target_api_if_needed() {
    [ -z "$TARGET_API" ] && {
        info "below is the supported target-apis:"
        list_target_apis
        info "please input your selected target-api:"
        read -r TARGET_API
        select_target_api_if_needed
    }
}

make_env() {
    is_package_available "$1" || die_from_package_is_not_available "$1"

    [ -z "$TARGET_API" ] && {
        TARGET_API=21
        warn "--target-api=VALUE argument is not specified. so, use the default value [21]."
    }
    
    [ -z "$TARGET_ABI" ] && {
        TARGET_ABI='armeabi-v7a'
        warn "--target-abi=VALUE argument is not specified. so, use the default value [armeabi-v7a]."
    }
    
    CMAKE_TOOLCHAIN_FILE="$ANDROID_NDK_HOME/build/cmake/android.toolchain.cmake"
    TOOLCHAIN_DIR="$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/$OS_NAME-$(uname -m)"
    SYSROOT="$TOOLCHAIN_DIR/sysroot"
    export PATH="$TOOLCHAIN_DIR/bin:$PATH"

    case "$TARGET_ABI" in
        armeabi-v7a) 
            export TOOLCHAIN_NAME='arm-linux-androideabi'
            export TARGET_HOST='armv7a-linux-androideabi'
            export TARGET_ARCH='arm'
            ;;
        arm64-v8a)
            export TOOLCHAIN_NAME='aarch64-linux-android'
            export TARGET_HOST='aarch64-linux-android'
            export TARGET_ARCH='arm64'
            ;;
        x86)
            export TOOLCHAIN_NAME='i686-linux-android'
            export TARGET_HOST='i686-linux-android'
            export TARGET_ARCH='x86'
            ;;
        x86_64)
            export TOOLCHAIN_NAME='x86_64-linux-android'
            export TARGET_HOST='x86_64-linux-android'
            export TARGET_ARCH='x86_64'
            ;;
        *)  export TOOLCHAIN_NAME='unkown'
            export TARGET_HOST='unkown'
            export TARGET_ARCH='unkown'
    esac

    
    FILE_PATH_LIBZ_SO="$TOOLCHAIN_DIR/sysroot/usr/lib/$TOOLCHAIN_NAME/$TARGET_API/libz.so"
    
    DIR_INSTALL_PACKAGE="$DIR_PKG/$1"
    DIR_INSTALL_PREFIX="$DIR_INSTALL_PACKAGE/$TARGET_ABI"
    [ -z "$DIR_SRC" ] || DIR_BUILD="$DIR_SRC/$TIMESTAMP_UNIX/$TARGET_ABI"

    info "-------------------------------------------------------"
    info "        PKG_NAME = $1"
    info "    DEPENDENCIES = $(get_direct_dependencies_of_a_package "$1")"
    info "ANDROID_NDK_HOME = $ANDROID_NDK_HOME"
    info "ANDROID_NDK_VER  = $ANDROID_NDK_VERSION"
    info "CMAKE_TOOLCHAIN_FILE = $CMAKE_TOOLCHAIN_FILE"
    info "FILE_PATH_LIBZ_SO = $FILE_PATH_LIBZ_SO"
    info "   TOOLCHAIN_DIR = $TOOLCHAIN_DIR"
    info "   TOOLCHAIN_NAME= $TOOLCHAIN_NAME"
    info "         SYSROOT = $SYSROOT"
    info "     TARGET_HOST = $TARGET_HOST"
    info "     TARGET_ARCH = $TARGET_ARCH"
    info "     TARGET_ABI  = $TARGET_ABI"
    info "     TARGET_API  = $TARGET_API"
    info "DIR_INSTALL_PACKAGE= $DIR_INSTALL_PACKAGE"
    info "DIR_INSTALL_PREFIX = $DIR_INSTALL_PREFIX"
    info "     DIR_SRC     = $DIR_SRC"
    info "     DIR_BUILD   = $DIR_BUILD"

    TOOLCHAIN_PREFIX="$TOOLCHAIN_DIR/bin/$TARGET_HOST$TARGET_API-"

    CC="${TOOLCHAIN_PREFIX}clang"
    is_exist_and_executable "$CC" && export CC="$CC"
    info "    CC = $CC"

    CXX="${TOOLCHAIN_PREFIX}clang++"
    is_exist_and_executable "$CXX" && export CXX="$CXX"
    info "   CXX = $CXX"
    
    if [ "$TARGET_HOST" = 'armv7a-linux-androideabi' ] ; then
        TOOLCHAIN_PREFIX="$TOOLCHAIN_DIR/bin/arm-linux-androideabi-"
    else
        TOOLCHAIN_PREFIX="$TOOLCHAIN_DIR/bin/$TARGET_HOST-"
    fi

    info "TOOLCHAIN_PREFIX = $TOOLCHAIN_PREFIX"
    
    AR="${TOOLCHAIN_PREFIX}ar"
    is_exist_and_executable "$AR" && export AR="$AR"
    info "    AR = $AR"

    AS="${TOOLCHAIN_PREFIX}as"
    is_exist_and_executable "$AS" && export AS="$AS"
    info "    AS = $AS"

    LD="${TOOLCHAIN_PREFIX}ld"
    is_exist_and_executable "$LD" && export LD="$LD"
    info "    LD = $LD"

    NM="${TOOLCHAIN_PREFIX}nm"
    is_exist_and_executable "$NM" && export NM="$NM"
    info "    NM = $NM"
     
    RANLIB="${TOOLCHAIN_PREFIX}ranlib"
    is_exist_and_executable "$RANLIB" && export RANLIB="$RANLIB"
    info "RANLIB = $RANLIB"
    
    STRIP="${TOOLCHAIN_PREFIX}strip"
    is_exist_and_executable "$STRIP" && export STRIP="$STRIP"
    info " STRIP = $STRIP"

    CPPFLAGS=''
    LDFLAGS=''

    for item in $(printf "$DEPENDENCIES")
    do
        item2=$(printf "$item" | tr '-' '_')
        ITEM_DIR_INSTALL_PREFIX="$DIR_PKG/$item/$TARGET_ABI"
        ITEM_DIR_INCLUDE="$ITEM_DIR_INSTALL_PREFIX/include"
        ITEM_DIR_LIB="$ITEM_DIR_INSTALL_PREFIX/lib"

        eval "${item2}_DIR_INSTALL_PREFIX='$ITEM_DIR_INSTALL_PREFIX'"
        eval "${item2}_DIR_INCLUDE='$ITEM_DIR_INCLUDE'"
        eval "${item2}_DIR_LIB='$ITEM_DIR_LIB'"
        CPPFLAGS="-I$ITEM_DIR_INCLUDE $CPPFLAGS"
        LDFLAGS="-L$ITEM_DIR_LIB     $LDFLAGS"
    done

    export CFLAGS='-Os -fpic -Qunused-arguments'
    
    [ "$VERBOSE" = 'true' ] && export CFLAGS="$CFLAGS -v"

    export CPPFLAGS="$CPPFLAGS -Qunused-arguments"
    export LDFLAGS="$LDFLAGS"
     
    info "CFLAGS  =$CFLAGS"
    info "CPPFLAGS=$CPPFLAGS"
    info "LDFLAGS =$LDFLAGS"
     
    info "-------------------------------------------------------"
}

parse_params() {
    unset TARGET_ABI
    unset TARGET_API
    unset TARGET_PACKAGE
    unset TARGET_PACKAGE_LIST
    unset COMMAND
    unset VERBOSE
    
    COMMAND="$1"
    
    shift
    
    while test -n "$1"
    do
        case "$1" in
            --target-api=[1-9][0-9])
                TARGET_API=$(getvalue "$1")
                ;;
            --target-abi=*)
                TARGET_ABI=$(getvalue "$1")
                ;;
            --verbose|-v)
                VERBOSE=true
                ;;
            --xtrace|-x)
                set -x
                ;;
            [a-z]*)
                if [ "$COMMAND" = 'env' ] ; then
                    if [ -z "$TARGET_PACKAGE" ] ; then
                        TARGET_PACKAGE="$1"
                    else
                        die "env command accept only one package name."
                    fi
                else
                    if [ -z "$TARGET_PACKAGE_LIST" ] ; then
                        TARGET_PACKAGE_LIST="$1"
                    else
                        TARGET_PACKAGE_LIST="$TARGET_PACKAGE_LIST $1"
                    fi
                    TARGET_PACKAGE_LIST=$(printf "$TARGET_PACKAGE_LIST")
                fi
                ;;
            *)  die "$1 is a invalid param."
        esac
        shift
    done
}

help() {
    cat << EOF
Usage: ndk-pkg [COMMAND [ARGUMENT...]]
COMMAND:
    help | --help | -h     --show help information.
    version | --version -V --print version of ndk-pkg and NDK.
    
    list target-abis       --list the supported target abis.
    list target-apis       --list the supported target api levels.
    list available         --list the available packages.
    list installed         --list the installed packages.
    list outdated          --list the outdated packages.

    is available PKG_NAME  --is PKG_NAME available?
    is installed PKG_NAME  --is PKG_NAME installed?
    is outdated  PKG_NAME  --is PKG_NAME outdated?
    
    search KEYWORD         --search packages.
    
    cat  PKG_NAME          --show the formula source code of a package.
    edit PKG_NAME          --edit the formula source code of a package.
    tree PKG_NAME          --list contents of a installed package directory in a tree-like format.
    pack PKG_NAME          --pack a installed package.
    logs PKG_NAME          --print the logs of a installed package.
    fetch PKG_NAME         --download formula resources of a package to the cache.
    prefix PKG_NAME        --show the installation direcotory of a formula or the ndk-pkg home.
    homepage PKG_NAME      --visit the homepage of a formula or the ndk-pkg project.
    
    env  PKG_NAME --target-api=21 --target-abi=armeabi-v7a -v -x
    
    install   PKG_NAME... [--target-api=21 -v -x]     --install packages.
    reinstall PKG_NAME... [--target-api=21 -v -x]     --reinstall packages.
    upgrade   PKG_NAME... [--target-api=21 -v -x]     --upgrade packages.
    uninstall PKG_NAME...                          --uninstall packages.
    info      PKG_NAME...                          --print the information of packages.
    
    cleanup          --cleanup the unused cache.
    update           --update the formula repository.
EOF
    if [ -z "$1" ] ; then
        exit
    else
        exit "$1"
    fi
}

main() {
    TIMESTAMP_UNIX="$(date +%s)"
    
    OS_NAME="$(uname -s | awk '{print(tolower($0))}')"
    case $OS_NAME in
        msys*|mingw*|cygwin*) OS_NAME=windows
    esac

    case $1 in
        --help|help|-h) 
            help
            ;;
        --version|version|-V)
            echo "ndk-pkg $NDK_PKG_VERSION"
            check_ANDROID_NDK_HOME
            echo "NDK     $(get_ndk_version)"
            ;;
        list)
            shift
            case "$1" in
                target-abis)
                    shift
                    list_target_abis
                    ;;
                target-apis)
                    shift
                    list_target_apis
                    ;;
                available)
                    shift
                    list_available_packages "$@"
                    ;;
                installed)
                    shift
                    list_installed_packages "$@"
                    ;;
                outdated)
                    shift
                    list_outdated_packages "$@"
                    ;;
                *) help 1
            esac
            ;;
        tree)
            shift
            tree_a_installed_package "$@"
            ;;
        search)
            shift
            search_packages "$*"
            ;;
        env) 
            check_ANDROID_NDK_HOME
            check_ANDROID_NDK_VERSION
            parse_params "$@"
            make_env "$TARGET_PACKAGE"
            ;;
        install)
            check_ANDROID_NDK_HOME
            check_ANDROID_NDK_VERSION
            parse_params "$@"
            install_packages
            ;;
        reinstall)
            check_ANDROID_NDK_HOME
            check_ANDROID_NDK_VERSION
            parse_params "$@"
            reinstall_packages
            ;;
        upgrade)
            check_ANDROID_NDK_HOME
            check_ANDROID_NDK_VERSION
            parse_params "$@"
            upgrade_packages
            ;;
        uninstall)
            shift
            uninstall_packages "$@"
            ;;
        info)
            shift
            info_packages "$@"
            ;;
        cat)
            shift
            cat_formula_of_a_package "$@"
            ;;
        edit)
            shift
            edit_formula_of_a_package "$@"
            ;;
        update)
            update_formula_repository;;
        cleanup)
            cleanup;;
        homepage)
            shift
            open_homepage_of_a_package "$@"
            ;;
        prefix)
            shift
            print_prefix_of_a_package "$@"
            ;;
        fetch)
            shift
            fetch_a_package "$@"
            ;;
        logs)
            shift
            logs_a_package "$@"
            ;;
        pack)
            shift
            pack_a_package "$@"
            ;;
        is)
            shift
            case $1 in
                available)
                    shift
                    is_package_available "$@"
                    ;;
                installed)
                    shift
                    is_package_installed "$@"
                    ;;
                outdated)
                    shift
                    is_package_outdated "$@"
                    ;;
                *) help 1
            esac
            ;;
        *) help 1
    esac
}

main "$@"
