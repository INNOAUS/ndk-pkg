#!/bin/sh

#------------------------------------------------------------------------------
# https://developer.android.google.cn/ndk/guides/other_build_systems
# https://clang.llvm.org/docs/CrossCompilation.html
# 
#------------------------------------------------------------------------------

COLOR_RED='\033[0;31m'          # Red
COLOR_GREEN='\033[0;32m'        # Green
COLOR_YELLOW='\033[0;33m'       # Yellow
COLOR_BLUE='\033[0;34m'         # Blue
COLOR_PURPLE='\033[0;35m'       # Purple
COLOR_OFF='\033[0m'             # Reset

msg() {
    printf "%b" "$*"
}

echo() {
    msg "$*\n"
}

info() {
    msg "${COLOR_PURPLE}$*\n${COLOR_OFF}"
}

success() {
    msg "${COLOR_GREEN}[âœ”] $*\n${COLOR_OFF}"
}

warn() {
    msg "${COLOR_YELLOW}ðŸ”¥ $*\n${COLOR_OFF}"
}

error() {
    msg "${COLOR_RED}[âœ˜] $*\n${COLOR_OFF}"
}

die() {
    msg "${COLOR_RED}[âœ˜] $*\n${COLOR_OFF}"
    exit 1
}

print_list() {
    for item in $@
    do
        echo "$item"
    done
}

nproc() {
    if command -v nproc > /dev/null ; then
        command nproc
    elif command -v sysctl > /dev/null ; then
        sysctl -n machdep.cpu.thread_count
    elif test -f /proc/cpuinfo ; then
        grep -c processor /proc/cpuinfo
    else
        echo 4
    fi
}

sed_in_place() {
    if command -v gsed > /dev/null ; then
        gsed -i "$1" "$2"
    elif command -v sed  > /dev/null ; then
        sed -i    "$1" "$2" 2> /dev/null || 
        sed -i "" "$1" "$2"
    else
        die "please install sed utility."
    fi
}

format_unix_timestamp() {
   date -jf "%s" "$1" "$2" 2> /dev/null ||
   date -d      "@$1" "$2"
}

getvalue() {
    echo "$1" | cut -d= -f2
}

prompt_user_to_install_bat() {
    warn "if you want to have a better experience, I strongly recommend you install ${COLOR_RED}bat${COLOR_OFF} on your os. For more details, see ${COLOR_RED}https://github.com/sharkdp/bat${COLOR_OFF}"
}

__fetch_via_git() {
    info "Fetching $FETCH_URL"

    if [ -d "$FETCH_OUTPUT_FILE_PATH" ] ; then
        if  git -C "$FETCH_OUTPUT_FILE_PATH" rev-parse 2> /dev/null ; then
            git -C "$FETCH_OUTPUT_FILE_PATH" pull
        else
            rm -rf "$FETCH_OUTPUT_FILE_PATH" &&
            git -C "$FETCH_OUTPUT_DIR" clone "$FETCH_URL" "$FETCH_OUTPUT_NAME"
        fi
    else
        git -C "$FETCH_OUTPUT_DIR" clone "$FETCH_URL" "$FETCH_OUTPUT_NAME"
    fi
    
    if [ $? -eq 0 ] ; then
        success "Fetched to $FETCH_OUTPUT_FILE_PATH success."
    else
        die "Fetched to $FETCH_OUTPUT_FILE_PATH failed."
    fi
}

__fetch_archive_via_tools() {
    if [ -f "$FETCH_OUTPUT_FILE_PATH" ] ; then
        if [ -n "$FETCH_OUTPUT_FILE_SHA256" ] ; then
            if is_sha256sum_match "$FETCH_OUTPUT_FILE_PATH" "$FETCH_OUTPUT_FILE_SHA256" ; then
                success "$FETCH_OUTPUT_FILE_PATH is already downloaded."
                return 0
            fi
        fi
        rm -f "$FETCH_OUTPUT_FILE_PATH"
    fi

    if command -v curl > /dev/null ; then
        info "Fetching $FETCH_URL"
        curl -L -o "$FETCH_OUTPUT_FILE_PATH" "$FETCH_URL"
    elif command -v wget > /dev/null ; then
        info "Fetching $FETCH_URL"
        wget -O "$FETCH_OUTPUT_FILE_PATH" "$FETCH_URL"
    else
        die "please install curl or wget."
    fi

    if [ $? -eq 0 ] ; then
        success "Fetched to $FETCH_OUTPUT_FILE_PATH success."
    else
        die "Fetched to $FETCH_OUTPUT_FILE_PATH failed."
    fi

    if [ -n "$FETCH_OUTPUT_FILE_SHA256" ] ; then
        die_if_sha256sum_mismatch "$FETCH_OUTPUT_FILE_PATH" "$FETCH_OUTPUT_FILE_SHA256"
    fi
}

#fetch <URL> [--output-dir=DIR | --output-name=NAME --sha256=SHA256]
fetch() {
    unset FETCH_URL
    unset FETCH_OUTPUT_DIR
    unset FETCH_OUTPUT_NAME
    unset FETCH_OUTPUT_FILE_PATH
    unset FETCH_OUTPUT_FILE_SHA256
    
    if [ -z "$1" ] ; then
        die "please specify a fetch url."
    else
        FETCH_URL="$1"
    fi
    
    shift
    
    while [ -n "$1" ]
    do
        case $1 in
            --sha256=*)
                FETCH_OUTPUT_FILE_SHA256=$(getvalue "$1")
                ;;
            --output-dir=*)
                FETCH_OUTPUT_DIR=$(getvalue "$1")
                if [ -z "$FETCH_OUTPUT_DIR" ] ; then
                    die "--output-dir argument's value must be not empty."
                else
                    if [ ! -d "$FETCH_OUTPUT_DIR" ] ; then
                        mkdir -p "$FETCH_OUTPUT_DIR"
                    fi
                fi
                ;;
            --output-name=*)
                FETCH_OUTPUT_NAME=$(getvalue "$1")
                if [ -z "$FETCH_OUTPUT_NAME" ] ; then
                    die "--output-name argument's value must be not empty."
                fi
                ;;
        esac
        shift
    done
    
    [ -z "$FETCH_OUTPUT_DIR" ]  && FETCH_OUTPUT_DIR="$PWD"
    [ -z "$FETCH_OUTPUT_NAME" ] && FETCH_OUTPUT_NAME=$(basename "$FETCH_URL")

    FETCH_OUTPUT_FILE_PATH="$FETCH_OUTPUT_DIR/$FETCH_OUTPUT_NAME"

    case $FETCH_URL in
        *.git) __fetch_via_git ;;
        *)     __fetch_archive_via_tools ;;
    esac
}

sha256sum() {
    die_if_file_is_not_exist "$1"

    if command -v openssl > /dev/null ; then
        openssl sha256 "$1" | awk '{print $2}'
    elif command sha256sum --version > /dev/null 2>&1 ; then
        sha256sum "$1" | awk '{print $1}'
    else
        die "please install openssl or GNU CoreUtils."
    fi
}

is_sha256sum_match() {
    die_if_file_is_not_exist "$1"
    [ -z "$2" ] && die "please specify sha256sum."
    [ "$(sha256sum $1)" = "$2" ]
}

die_if_sha256sum_mismatch() {
    is_sha256sum_match "$1" "$2" || die "sha256sum mismatch."
}

unzip() {
    info "uncompressing $1"
    
    if command unzip "$1" ; then
        success "uncompressed in $2"
    else
        die "uncompress $1 failed!"
    fi
}

untar() {
    info "uncompressing $1"
    
    if tar xf "$1" --strip-components 1 ; then
        success "uncompressed in $2"
    else
        die "uncompress $1 failed!"
    fi
}

uncompress() {
    case $1 in
        *.zip)
            unzip "$1" "$2" ;;
        *.tar.xz|*.tar.gz|*.tar.bz2|*.tgz|*.txz)
            untar "$1" "$2" ;;
        *)  die "$1 : extension isn't recognized. the supported extensions are .zip .tar.xz .tar.gz .tar.bz2 .tgz .txz"
    esac
}

fetch_a_package() {
    die_if_load_formula_failed "$1"
    case $url in
        dir://*) ;;
              *) fetch "$url" --output-dir="$MY_CACHED_DIR" --output-name="$FETCH_OUTPUT_NAME" --sha256="$sha256"
    esac
}

die_if_file_is_not_exist() {
    [ -z "$1" ] && die "please specify a file path."
    [ -f "$1" ] || die "$1 is not exist."
}

die_if_file_is_not_executable() {
    die_if_file_is_not_exist "$1"
    [ -x "$1" ] || die "$1 is not executable."
}

die_if_abi_____is_not_specified() {
    [ -z "$1" ] && die "please specify a abi."
}

die_if_abi_____is_not_supported() {
    die_if_abi_____is_not_specified "$1"
    
    for ABI in $(list_supported_abis)
    do
        [ "$ABI" = "$1" ] && return 0
    done

    die "$1 abi is not supported."
}

die_if_package_is_not_specified() {
    [ -z "$1" ] && die "please specify a package name."
}

die_if_package_list_is_not_specified() {
    [ -z "$1" ] && die "please specify at least one package name."
}

die_if_package_is_not_available() {
    is_package_available "$1" || die "$1 is not available."
}

die_if_package_is_already_exist() {
    die_if_package_is_not_specified "$1"
    [ -f "$MY_FORMULA_DIR/$1.sh" ] && die "$1 package is already exist."
}

die_from_package_is_not_installed() {
    die "$1 is not installed."
}

die_if_package_is_not_installed() {
    is_package_installed "$1" || die_from_package_is_not_installed "$1"
}

is_package_available() {
    die_if_package_is_not_specified "$1"
    [ -f "$MY_FORMULA_DIR/$1.sh" ]
}

is_package_installed() {
    die_if_package_is_not_specified "$1"
    
    [ -d "$MY_INSTALL_DIR/$1" ]              || return 1
    [ -f "$MY_INSTALL_DIR/$1/manifest.txt" ] || return 1

    for ABI in $(cat "$MY_INSTALL_DIR/$1/manifest.txt")
    do
        [ -d "$MY_INSTALL_DIR/$1/$ABI" ]                       || return 1
        [ -d "$MY_INSTALL_DIR/$1/$ABI/log" ]                   || return 1
        [ -f "$MY_INSTALL_DIR/$1/$ABI/log/installed.log.txt" ] || return 1
    done
}

is_package__outdated() {
    die_if_load_formula_failed "$1"

    [ -d "$MY_INSTALL_DIR/$1" ]              || die_from_package_is_not_installed "$1"
    [ -f "$MY_INSTALL_DIR/$1/manifest.txt" ] || die_from_package_is_not_installed "$1"

    for ABI in $(cat "$MY_INSTALL_DIR/$1/manifest.txt")
    do
        [ -d "$MY_INSTALL_DIR/$1/$ABI" ]                       || die_from_package_is_not_installed "$1"
        [ -d "$MY_INSTALL_DIR/$1/$ABI/log" ]                   || die_from_package_is_not_installed "$1"
        [ -f "$MY_INSTALL_DIR/$1/$ABI/log/installed.log.txt" ] || die_from_package_is_not_installed "$1"
        die_if_load_installed_log_failed "$1" "$ABI"
        [ "$version" = "$installed_pkg_version" ] && return 1
        [ "$version" = $(printf "$version\n$installed_pkg_version" | sort --version-sort --reverse | head -n 1) ]
    done
}

list_available_packages() {
    unset SILENT

    case $# in
        0)  ;;
        1)  if [ "$1" = '-q' ] ; then
                SILENT=true
            else
                die "list available action only accept -q argument."
            fi
            ;;
        *)  die "list available action only accept -q argument."
    esac

    [ -d "$MY_FORMULA_DIR" ] || {
        if [ "$SILENT" = 'true' ] ; then
            update_formula_repository >/dev/null 2>&1
        else
            update_formula_repository
        fi
    }
    
    if [ "$SILENT" = 'true' ] ; then
        cd "$MY_FORMULA_DIR" 2>/dev/null || exit 1
    else
        cd "$MY_FORMULA_DIR" || exit 1
    fi

    for item in $(ls *.sh | sed 's/\.sh//g')
    do
        echo "$item"
    done
}

list_installed_packages() {
    cd "$MY_INSTALL_DIR" 2>/dev/null || exit 1

    for packageName in *
    do
        if is_package_installed "$packageName" ; then
            echo "$packageName"
        fi
    done
}

list__outdated_packages() {
    cd "$MY_INSTALL_DIR" 2>/dev/null || exit 1

    for packageName in *
    do
        is_package_available "$packageName" || continue
        is_package_installed "$packageName" || continue
        is_package__outdated "$packageName" || continue
        echo "$packageName"
    done
}

list_abis_of_a_installed_package() {
    die_if_package_is_not_installed "$1"
    cat "$MY_INSTALL_DIR/$1/manifest.txt"
}

tree_a_package() {
    die_if_package_is_not_installed "$1"

    PKG_INSTALL_DIR="$MY_INSTALL_DIR/$1"

    shift

    if command -v tree > /dev/null ; then
        tree $@ --dirsfirst "$PKG_INSTALL_DIR"
    else
        warn "please install tree utility."
    fi
}

uninstall_packages() {
    shift

    die_if_package_list_is_not_specified "$1"
    
    for packageName in $@
    do
        uninstall_a_package "$packageName" || return 1
    done
}

uninstall_a_package() {
    die_if_package_is_not_installed "$1"

    info "uninstalling $1..." &&
    rm -rf "$MY_INSTALL_DIR/$1" &&
    success "$1 uninstalled."
}

view_a_formula() {
    die_if_package_is_not_available "$1"

    [ -z "$2" ] || warn "view action accept only one argument."
    
    if command -v bat > /dev/null ; then
        bat "$MY_FORMULA_DIR/$1.sh"
    else
        cat "$MY_FORMULA_DIR/$1.sh"
        echo
        prompt_user_to_install_bat
    fi    
}

edit_a_formula() {
    die_if_package_is_not_available "$1"

    [ -z "$2" ] || warn "edit action accept only one argument."

    [ -z "$EDITOR" ] &&
    EDITOR=$(command -v nvim) ||
    EDITOR=$(command -v vim) ||
    EDITOR=$(command -v vi) ||
    EDITOR=$(command -v open) ||
    die "please set EDITOR environment variable."

    "$EDITOR" "$MY_FORMULA_DIR/$1.sh"
}

create_a_formula() {
    die_if_package_is_already_exist "$1"

    cat > "$MY_FORMULA_DIR/$1.sh" <<EOF
summary="Summary of this package"

homepage="https://www.xx.com"

# the source code download url of this package. the value of url must end with one of .git .zip .tar.xz .tar.gz .tar.bz2 .tar.tgz .tar.txz
url="https://www.xx.com/pkgname-x.y.z.tar.gz"

# the version of this package. If this variable is not declared, it will be calculated from url.
#version=x.y.z

# the sha256sum of source code. If the value of url end with .git, this variable is optional, otherwise, this variable must be declared.
sha256="c3e5e9fdd5004dcb542feda5ee4f0ff0744628baf8ed2dd5d66f8ca1197cb1a1"

# the dependencies of this package. If specify multiple values, separate them with spaces.
#dependencies="a b c"

prepare() {
    :
    #this function is optional, you can delete it, if don't use it.
}

build() {
    :
    #configure
    #cmake
    #meson
    #$MAKE
}
EOF
    edit_a_formula "$1"
}

delete_a_formula() {
    die_if_package_is_not_available "$1"

    if rm "$MY_FORMULA_DIR/$1.sh" ; then
        success "delete $1 formula success."
    else
        die "delete $1 formula failed."
    fi
}

rename_a_formula() {
    die_if_package_is_not_available "$1"
    die_if_package_is_already_exist "$2"

    if mv "$MY_FORMULA_DIR/$1.sh" "$MY_FORMULA_DIR/$2.sh" ; then
        success "rename formula $1 -> $2 success."
    else
        die "rename formula $1 -> $2 failed."
    fi   
}

update_formula_repository() {
    info "Updating formula repository."
    fetch "$MY_FORMULA_REPO_URL" --output-dir="$MY_HOME_DIR" --output-name=formula
}

upgrade_packages() {
    check_prerequisites
    parse_arguments "$@"

    [ -z "$TO_BE_INSTALLED_PACKAGE_LIST" ] && TO_BE_INSTALLED_PACKAGE_LIST=$(list__outdated_packages)
    [ -z "$TO_BE_INSTALLED_PACKAGE_LIST" ] && return 0

    reinstall_packages
}

reinstall_packages() {
    check_prerequisites
    parse_arguments "$@"

    die_if_package_list_is_not_specified "$TO_BE_INSTALLED_PACKAGE_LIST"

    for packageName in $TO_BE_INSTALLED_PACKAGE_LIST
    do
        die_if_package_is_not_available "$packageName"
        die_if_package_is_not_installed "$packageName"
    done
    
    for packageName in $TO_BE_INSTALLED_PACKAGE_LIST
    do
        {
            [ -d "$MY_BACKUP_DIR" ] || mkdir -p "$MY_BACKUP_DIR"
        } &&
        mv "$MY_INSTALL_DIR/$packageName" "$MY_BACKUP_DIR/$packageName" &&
        install_a_package "$packageName" &&
        rm -rf "$MY_BACKUP_DIR/$packageName"
    done
}

cleanup() {
    success "Done."
}

search_packages() {
    [ -z "$1" ] && die "please specify a keyword."
    [ -d "$MY_FORMULA_DIR" ] || update_formula_repository
    
    cd "$MY_FORMULA_DIR" || exit 1

    for item in $(ls -1 *.sh | sed 's/\.sh//g')
    do
        echo "$item" | grep "$*" || true
    done
}

open_homepage_of_a_package() {
    if [ -z "$1" ] ; then
        homepage="$MY_HOME_PAGE"
    else
        die_if_load_formula_failed "$1"
    fi
    
    if command -v open > /dev/null ; then
        open "$homepage"
    else
        echo "$homepage"
    fi
}

print_prefix_of_a_package() {
    if [ -z "$1" ] ; then
        echo "$MY_HOME_DIR"
    else
        die_if_package_is_not_installed "$1"
        echo "$MY_INSTALL_DIR/$1"
    fi
}

logs_a_package() {
    die_if_package_is_not_installed "$1"
    die_if_abi_____is_not_supported "$2"

    if command -v bat > /dev/null ; then
        VIEWER=bat
    else
        VIEWER=less
    fi

    for item in $(ls "$MY_INSTALL_DIR/$1/$2/log"/*.log.txt)
    do
        case $item in
            *.sh.log.txt|*/installed.log.txt)
                bat -l bash "$item";;
            *)
                if [ "$VIEWER" = 'bat' ] ; then
                    bat "$item"
                else
                    "$VIEWER" "$item"
                fi
        esac
    done

    if [ "$VIEWER" != 'bat' ] ; then
        prompt_user_to_install_bat
    fi
}

pack_a_package_via_zip() {
    die_if_package_is_not_installed "$1"
    
    install -d "$MY_BOTTLE_DIR" || return 1

    cd "$MY_INSTALL_DIR" || return 1

    FILE_PATH_BOTTLE="$MY_BOTTLE_DIR/$1-bottle.zip"

    info "packing $1 ..."

    if zip -r "$FILE_PATH_BOTTLE" "$1" ; then
        success "packed $1 success. $FILE_PATH_BOTTLE"
    else
        die "packed $1 failed."
    fi
}

pack_a_package_via_tar_gzip() {
    die_if_package_is_not_installed "$1"
    
    install -d "$MY_BOTTLE_DIR" || return 1

    FILE_PATH_BOTTLE="$MY_BOTTLE_DIR/$1-bottle.tar.gz"

    info "packing $1 ..."
    
    if tar zvcf "$FILE_PATH_BOTTLE" -C "$MY_INSTALL_DIR" "$1" ; then
        success "packed $1 success. $FILE_PATH_BOTTLE"
    else
        die "packed $1 failed."
    fi
}

pack_a_package_via_tar_xz() {
    die_if_package_is_not_installed "$1"
    
    install -d "$MY_BOTTLE_DIR" || return 1

    FILE_PATH_BOTTLE="$MY_BOTTLE_DIR/$1-bottle.tar.xz"

    info "packing $1 ..."

    if tar Jvcf "$FILE_PATH_BOTTLE" -C "$MY_INSTALL_DIR" "$1" ; then
        success "packed $1 success. $FILE_PATH_BOTTLE"
    else
        die "packed $1 failed."
    fi
}

pack_a_package_via_tar_bzip2() {
    die_if_package_is_not_installed "$1"
    
    install -d "$MY_BOTTLE_DIR" || return 1

    FILE_PATH_BOTTLE="$MY_BOTTLE_DIR/$1-bottle.tar.bz2"

    info "packing $1 ..."

    if tar jvcf "$FILE_PATH_BOTTLE" -C "$MY_INSTALL_DIR" "$1" ; then
        success "packed $1 success. $FILE_PATH_BOTTLE"
    else
        die "packed $1 failed."
    fi
}

pack_a_package() {
    if command -v zip > /dev/null ; then
        pack_a_package_via_zip "$1"
    elif command -v tar > /dev/null ; then
        if command -v gzip > /dev/null ; then
            pack_a_package_via_tar_gzip "$1"
        elif command -v xz > /dev/null ; then
            pack_a_package_via_tar_xz "$1"
        elif command -v bzip2 > /dev/null ; then
            pack_a_package_via_tar_bzip2 "$1"
        else
            die "please install gzip or xz or bzip2 utility."
        fi
    else
        die "please install zip or tar utility."
    fi
}

get_direct_dependency_package_list_of_a_package() {
    grep '^\s*dependencies=".*"' "$MY_FORMULA_DIR/$1.sh" | sed 's/.*dependencies="\(.*\)"/\1/'
}

resolve_DEPENDENCY_PACKAGE_LIST_of_a_package() {
    for dependencyPkgName in $(get_direct_dependency_package_list_of_a_package "$1")
    do
        die_if_package_is_not_available "$dependencyPkgName"

        DEPENDENCY_PACKAGE_LIST_TEMP=""

        for item in $DEPENDENCY_PACKAGE_LIST
        do
            if [ "$dependencyPkgName" = "$item" ] ; then
                continue
            else
                DEPENDENCY_PACKAGE_LIST_TEMP="$DEPENDENCY_PACKAGE_LIST_TEMP $item"
            fi
        done
        
        DEPENDENCY_PACKAGE_LIST="$dependencyPkgName $DEPENDENCY_PACKAGE_LIST_TEMP"

        resolve_DEPENDENCY_PACKAGE_LIST_of_a_package "$dependencyPkgName"
    done
}

install_packages() {
    check_prerequisites
    parse_arguments "$@"

    die_if_package_list_is_not_specified "$TO_BE_INSTALLED_PACKAGE_LIST"
    
    for TO_BE_INSTALLED_PACKAGE in $TO_BE_INSTALLED_PACKAGE_LIST
    do
        resolve_DEPENDENCY_PACKAGE_LIST_of_a_package "$TO_BE_INSTALLED_PACKAGE"
    done
    
    for TO_BE_INSTALLED_PACKAGE in $DEPENDENCY_PACKAGE_LIST $TO_BE_INSTALLED_PACKAGE_LIST
    do
        if is_package_installed "$TO_BE_INSTALLED_PACKAGE" ; then
            success "$TO_BE_INSTALLED_PACKAGE is already installed."
        else
            install_a_package "$TO_BE_INSTALLED_PACKAGE"
        fi
    done
}

__prepare_installation() {
    if [ -z "$SHELL" ] ; then
        SHELL=$(command -v zsh) ||
        SHELL=$(command -v bash) ||
        SHELL=$(command -v sh)
    fi

    if [ -z "$MAKE" ] ; then
        MAKE=$(command -v gmake) ||
        MAKE=$(command -v make)
    fi

    if [ -z "$NINJA" ] ; then
        NINJA=$(command -v ninja) ||
        NINJA=$(command -v ninja-build)
    fi

    if [ -z "$PKG_CONFIG" ] ; then
        PKG_CONFIG=$(command -v pkg-config) ||
        PKG_CONFIG=$(command -v pkgconfig) ||
        PKG_CONFIG=$(command -v pkgconf)
    fi

    for item in $(echo "$PATH" | tr ':' ' ')
    do
        if [ -z "$CMAKE" ] ; then
            if [ -f "$item/cmake" ] && [ -x "$item/cmake" ] ; then
                CMAKE="$item/cmake"
            fi
        fi

        if [ -z "$MESON" ] ; then
            if [ -f "$item/meson" ] && [ -x "$item/meson" ] ; then
                MESON="$item/meson"
            fi
        fi

        if [ -n "$CMAKE" ] && [ -n "$MESON" ] ; then
            break
        fi
    done

    if [ -z "$CC" ] ; then
        CC=$(command -v cc) ||
        CC=$(command -v gcc) ||
        CC=$(command -v clang)
    fi

    if [ -z "$CXX" ] ; then
        CXX=$(command -v c++) ||
        CXX=$(command -v g++) ||
        CXX=$(command -v clang++)
    fi

    if [ -z "$AR" ] ; then
        AR=$(command -v ar)
    fi

    if [ -z "$RANLIB" ] ; then
        RANLIB=$(command -v ranlib)
    fi

    export CC="$CC"
    export CXX="$CXX"
    export AR="$AR"
    export RABLIB="$RANLIB"
    export CFLAGS="$CFLAGS"
    export CXXFLAGS="$CXXFLAGS"
    export CPPFLAGS="$CPPFLAGS"
    export LDFLAGS="$LDFLAGS"

    export CC_FOR_BUILD="$CC"
    export CXX_FOR_BUILD="$CXX"
    export AR_FOR_BUILD="$AR"
    export RABLIB_FOR_BUILD="$RANLIB"
    export CFLAGS_FOR_BUILD="$CFLAGS"
    export CXXFLAGS_FOR_BUILD="$CXXFLAGS"
    export CPPFLAGS_FOR_BUILD="$CPPFLAGS"
    export LDFLAGS_FOR_BUILD="$LDFLAGS"

    export PATH="$TOOLCHAIN_DIR/bin:$PATH"
}

die_if_command_not_found() {
    case $1 in
        make) [ -z "$MAKE" ]  && die_from_command_not_found "$1"  "MAKE" ;;
       cmake) [ -z "$CMAKE" ] && die_from_command_not_found "$1" "CMAKE" ;;
       meson) [ -z "$MESON" ] && die_from_command_not_found "$1" "MESON" ;;
       ninja) [ -z "$NINJA" ] && die_from_command_not_found "$1" "NINJA" ;;
       pkg-config|pkgconfig|pkgconf)
              [ -z "$PKG_CONFIG" ] && die_from_command_not_found "$1" "PKG_CONFIG" ;;
           *) command -v "$requirement" > /dev/null || die_from_command_not_found "$1"
    esac
}

die_from_command_not_found() {
    if [ -z "$2" ] ; then
        die "command not found: $1. please make sure it in PATH."
    else
        die "command not found: $1. please make sure it in PATH or export $2=path/to/$1 environment."
    fi
}

die_from_installation_failed() {
    if [ -z "$BUILD_FOR_ABI" ] ; then
        die "install $1 failed! you can go to $WORKING_DIR to see see."
    else
        die "install $1/$BUILD_FOR_ABI failed! you can go to $WORKING_DIR to see see."
    fi
}

install_a_package() {
    unset BUILD_FOR_ABI
    unset BUILD_FOR_ARCH
    unset BUILD_FOR_HOST

    fetch_a_package "$1"

    __prepare_installation

    for requirement in $requirements
    do
        die_if_command_not_found "$requirement"
    done

    if WORKING_DIR=$(mktemp -d) ; then
        SOURCE_DIR="$WORKING_DIR"
        cd "$WORKING_DIR" || exit 1
    else
        die "create working directory failed."
    fi

    case $url in
        dir://*)cp -rv     "$FETCH_OUTPUT_FILE_PATH"/* "$WORKING_DIR" ;;
        *.git)  cp -rv     "$FETCH_OUTPUT_FILE_PATH"/* "$WORKING_DIR" ;;
        *)      uncompress "$FETCH_OUTPUT_FILE_PATH"   "$WORKING_DIR" ;;
    esac
    
    if command -v prepare > /dev/null ; then
        prepare || die_from_installation_failed "$1"
    fi

    install_a_package_all_builds "$1" || die_from_installation_failed "$1"

    if [ "$KEEP_WORKING_DIR" != 'true' ] ; then
        rm -rf "$WORKING_DIR"
    fi
}

install_a_package_all_builds() {
    for BUILD in $BUILD_LIST
    do
        install_a_package_one_build "$1" || return 1
    done

    if [ ! -d "$PKG_INSTALL_DIR" ] ; then
        die "all build passed, but installed nothing. you can go to $WORKING_DIR to see see."
    fi

    echo "$BUILD_FOR_ABI_LIST" > "$PKG_INSTALL_DIR/manifest.txt"

    success "$1 installed success. in $PKG_INSTALL_DIR directory."
    
    tree_a_package "$1" || true
}

install_a_package_one_build() {
    config_vars "$1" &&
    export_vars &&
    {
        if [ "$DRYRUN" = 'true' ] ; then
            printf_vars "$1" &&
            exec "$SHELL"
        else
            (
            cd "$BUILD_DIR" &&
            mkfifo pipe &&
            (tee install.log.txt < pipe &) &&
            {
                printf_vars "$1" &&
                rm -rf "$ABI_INSTALL_DIR" &&
                build &&
                __justfy_pc_files
            } > pipe 2>&1
            )
        fi
    } &&
    {
        LOG_DIR="$ABI_INSTALL_DIR/log"

        install -d "$LOG_DIR" || return 1

        install_installed_log

        install -m 644 "$MY_FORMULA_DIR/$1.sh" "$LOG_DIR/$1.sh.log.txt" || return 1

        if [ -f "$SOURCE_DIR/config.log" ] ; then
            install -m 644 "$SOURCE_DIR/config.log" "$LOG_DIR/config.log.txt" || return 1
        fi

        if [ -f "$BUILD_DIR/config.log" ] ; then
            install -m 644 "$BUILD_DIR/config.log" "$LOG_DIR/config.log.txt" || return 1
        fi

        if [ -f "$BUILD_DIR/install.log.txt" ] ; then
            install -m 644 "$BUILD_DIR/install.log.txt" "$LOG_DIR" || return 1
        fi
    }
}

__justfy_pc_files() {
    if [ -d "$ABI_INSTALL_DIR/lib/pkgconfig" ] ; then
        cd  "$ABI_INSTALL_DIR/lib/pkgconfig" || return 1
        for item in $(find . -name "*.pc")
        do
            __justfy_a_file "$item"
        done
    fi
}

__justfy_a_file() {
    die_if_file_is_not_exist "$1"

    sed_in_place 's/-lpthread//g' "$1" || return 1

    if grep 'Libs.private:' "$1" > /dev/null ; then
        LIBS_CONTENT=$(awk '/Libs:/{print}' "$1")
        LIBS_PRIVATE_CONTENT=$(awk -F: '/Libs.private:/{print $2}' "$1") &&
        sed_in_place "s|$LIBS_CONTENT|$LIBS_CONTENT$LIBS_PRIVATE_CONTENT|" "$1" &&
        sed_in_place '/Libs.private/d' "$1"
    fi
}

info_packages() {
    unset INFO
    unset PACKAGE
    unset PACKAGE_LIST

    if [ -z "$1" ] ; then
        [ -d "$MY_FORMULA_DIR" ] || update_formula_repository
        cd "$MY_FORMULA_DIR" || exit 1
        PACKAGE_LIST=$(ls *.sh | sed 's/\.sh//g')
    else
        PACKAGE_LIST=$@
    fi

    for PACKAGE in $PACKAGE_LIST
    do
        if [ "$INFO" = 'true' ] ; then
            echo "============================================================"
        else
            INFO=true
        fi
        info_a_package "$PACKAGE"
    done
}

info_a_package() {
    die_if_load_formula_failed "$1"

    echo "name      : $(mark_is_package_installed_or_not $1)"

    if [ -n "$version" ] ; then
        echo "version   : $version"
    fi

    echo "summary   : $summary"
    echo "homepage  : $homepage"

    [ -z "$dependencies" ] || {
        unset DEPENDENCIES

        for dependencyPkgName in $dependencies
        do
            if [ -z "$DEPENDENCIES" ] ; then
                DEPENDENCIES="depend_on : $(mark_is_package_installed_or_not $dependencyPkgName)"
            else
                DEPENDENCIES="$DEPENDENCIES | $(mark_is_package_installed_or_not $dependencyPkgName)"
            fi
        done

        echo "$DEPENDENCIES"
    }

    echo "src_url   : $url"

    FETCH_OUTPUT_FILE_PATH="$MY_CACHED_DIR/$FETCH_OUTPUT_NAME"

    case $url in
        dir://*) ;;
        *.git)
            if [ -d "$FETCH_OUTPUT_FILE_PATH" ] ; then
                echo "src_cache ${COLOR_PURPLE}==>${COLOR_OFF} $FETCH_OUTPUT_FILE_PATH"
            else
                echo "src_cache : ${COLOR_RED}Not cached${COLOR_OFF}"
            fi
            ;;
        *)
            if [ -f "$FETCH_OUTPUT_FILE_PATH" ] ; then
                echo "src_cache ${COLOR_PURPLE}==>${COLOR_OFF} $FETCH_OUTPUT_FILE_PATH"
            else
                echo "src_cache : ${COLOR_RED}Not cached${COLOR_OFF}"
            fi
    esac

    if is_package_installed "$1" ; then
        echo "installed ${COLOR_PURPLE}==>${COLOR_OFF} $(du -sh "$MY_INSTALL_DIR/$1" | awk '{print $2, $1}')"
        for ABI in $(cat "$MY_INSTALL_DIR/$1/manifest.txt")
        do
            echo "              â”œâ”€â”€ $(printf "%-12s" "$ABI") $(du -sh "$MY_INSTALL_DIR/$1/$ABI" | awk '{print $1}')"
        done
        die_if_load_installed_log_failed "$1" "$ABI"
        print_installed_log "$1" "$ABI"
    fi
}

mark_is_package_installed_or_not() {
    if is_package_installed "$1" ; then
        echo "${COLOR_GREEN}$1${COLOR_OFF}"
    else
        echo "${COLOR_RED}$1${COLOR_OFF}"
    fi
}

die_if_load_formula_failed() {
    die_if_package_is_not_available "$1"

    unset -f prepare
    unset -f build
    unset -f build_configed
    unset url
    unset sha256
    unset version
    unset summary
    unset homepage
    unset requirements
    unset dependencies
    
    FORMULA_FILE_PATH="$MY_FORMULA_DIR/$1.sh"
     
    . "$FORMULA_FILE_PATH" || die "$FORMULA_FILE_PATH is broken."
    
    [ -z "$summary" ]  && die "summary variable must be specified in $FORMULA_FILE_PATH"
    [ -z "$homepage" ] && die "homepage variable must be specified in $FORMULA_FILE_PATH"
    [ -z "$url" ]      && die "url variable must be specified in $FORMULA_FILE_PATH"

    case $url in
        dir://*)   URL_CONTENT_TYPE=dir ;;
        *.git)     URL_CONTENT_TYPE=git ;;
        *.zip)     URL_CONTENT_TYPE=zip ;;
        *.tar.xz)  URL_CONTENT_TYPE=tar.xz ;;
        *.tar.gz)  URL_CONTENT_TYPE=tar.gz ;;
        *.tar.bz2) URL_CONTENT_TYPE=tar.bz2;;
        *.tgz)     URL_CONTENT_TYPE=tar.gz ;;
        *.txz)     URL_CONTENT_TYPE=tar.xz ;;
        *)  die "$url : extension isn't recognized. the supported extensions are .git .zip .tar.xz .tar.gz .tar.bz2 .tgz .txz"
    esac

    case $URL_CONTENT_TYPE in
        dir)
            if command -v cut > /dev/null ; then
                FETCH_OUTPUT_FILE_PATH=$(echo $url | cut -c7-${#url})
            elif command -v awk > /dev/null ; then
                FETCH_OUTPUT_FILE_PATH=$(echo $url | awk '{print(substr($0, 7))}')
            else
                FETCH_OUTPUT_FILE_PATH=$(expr substr "$url" 7 ${#url})
            fi
            [ -d "$FETCH_OUTPUT_FILE_PATH" ] || "url variable point to dir is not exist."
            ;;
        git) FETCH_OUTPUT_NAME="$1.git" ;;
        *)
            if [ -z "$sha256" ] ; then
                die "sha256 variable is not declared in $FORMULA_FILE_PATH"
            fi
            if [ -z "$version" ] ; then
                version="$(basename "$url" | awk '{str = tolower($0); gsub(".tar.xz", "", str); gsub(".tar.gz", "", str); gsub(".tar.bz2", "", str); gsub(".tgz", "", str); gsub(".txz", "", str); gsub(".zip", "", str); print(str)}' | awk -F- '{print $NF}')"
                if [ -z "$version" ] ; then
                    die "version variable is not declared in $FORMULA_FILE_PATH"
                fi
            fi
            FETCH_OUTPUT_NAME="$1-$version.$URL_CONTENT_TYPE"
    esac
}

install_installed_log() {
    cat > "$LOG_DIR/installed.log.txt" <<EOF
installed_datetime=$TIMESTAMP_UNIX
installed_pkg_version=$version
min_sdk_api_level=$MIN_SDK_API_LEVEL
using_ndk_version=$ANDROID_NDK_VERSION
EOF
}

die_if_load_installed_log_failed() {
    die_if_package_is_not_installed "$1"
    die_if_abi_____is_not_supported "$2"

    INSTALLED_LOG_FILE_PATH="$MY_INSTALL_DIR/$1/$2/log/installed.log.txt"

    unset installed_datetime
    unset installed_pkg_version
    unset min_platform_version
    unset using_xcode_version
    
    . "$INSTALLED_LOG_FILE_PATH" || die "$INSTALLED_LOG_FILE_PATH is broken."
}

print_installed_log() {
    echo "installed_datetime    : $(format_unix_timestamp $installed_datetime '+%Y/%m/%d %H:%M:%S')"
    echo "installed_pkg_version : $installed_pkg_version"
    echo "min_sdk_api_level : $min_sdk_api_level"
    echo "using_ndk_version : $using_ndk_version"
}

config_vars() {
    die_if_package_is_not_available "$1"

    BUILD_ROUND_NUM=$(expr ${BUILD_ROUND_NUM-0} + 1)

    BUILD_FOR_ABI=$BUILD

    case "$BUILD_FOR_ABI" in
        armeabi-v7a)
            TOOLCHAIN_NAME='arm-linux-androideabi'
            BUILD_FOR_HOST='armv7a-linux-androideabi'
            BUILD_FOR_ARCH='arm'
            BUILD_FOR_CPU_FAMILY='arm'
            BUILD_FOR_CPU_NAME='armv7a'
            ;;
        arm64-v8a)
            TOOLCHAIN_NAME='aarch64-linux-android'
            BUILD_FOR_HOST='aarch64-linux-android'
            BUILD_FOR_ARCH='arm64'
            BUILD_FOR_CPU_FAMILY='aarch64'
            BUILD_FOR_CPU_NAME='armv8a'
            ;;
        x86)
            TOOLCHAIN_NAME='i686-linux-android'
            BUILD_FOR_HOST='i686-linux-android'
            BUILD_FOR_ARCH='x86'
            BUILD_FOR_CPU_FAMILY='x86'
            BUILD_FOR_CPU_NAME='i686'
            ;;
        x86_64)
            TOOLCHAIN_NAME='x86_64-linux-android'
            BUILD_FOR_HOST='x86_64-linux-android'
            BUILD_FOR_ARCH='x86_64'
            BUILD_FOR_CPU_FAMILY='x86_64'
            BUILD_FOR_CPU_NAME='x86_64'
            ;;
        *)  TOOLCHAIN_NAME='unkown'
            BUILD_FOR_HOST='unkown'
            BUILD_FOR_ARCH='unkown'
            BUILD_FOR_CPU_FAMILY='unkown'
            BUILD_FOR_CPU_NAME='unkown'
    esac

    TOOLCHAIN_PREFIX="$TOOLCHAIN_DIR/bin/$BUILD_FOR_HOST$MIN_SDK_API_LEVEL-"

    CC="${TOOLCHAIN_PREFIX}clang"
   CXX="${TOOLCHAIN_PREFIX}clang++"
   CPP="$CC -E"
    
    TOOLCHAIN_PREFIX="$TOOLCHAIN_DIR/bin/$TOOLCHAIN_NAME-"
    
        AR="${TOOLCHAIN_PREFIX}ar"
        AS="${TOOLCHAIN_PREFIX}as"
        LD="${TOOLCHAIN_PREFIX}ld"
        NM="${TOOLCHAIN_PREFIX}nm"
    RANLIB="${TOOLCHAIN_PREFIX}ranlib"
     STRIP="${TOOLCHAIN_PREFIX}strip"

    die_if_file_is_not_executable "$CC"
    die_if_file_is_not_executable "$CXX"
    die_if_file_is_not_executable "$AR"
    die_if_file_is_not_executable "$AS"
    die_if_file_is_not_executable "$LD"
    die_if_file_is_not_executable "$NM"
    die_if_file_is_not_executable "$RANLIB"
    die_if_file_is_not_executable "$STRIP"

    SYSTEM_INCLUDE_DIR="$SYSROOT/usr/include"
    SYSTEM_LIBRARY_DIR="$SYSROOT/usr/lib/$TOOLCHAIN_NAME/$MIN_SDK_API_LEVEL"

      CFLAGS="--sysroot $SYSROOT -Qunused-arguments -Os -fpic"
    CPPFLAGS="--sysroot $SYSROOT -Qunused-arguments"
     LDFLAGS="--sysroot $SYSROOT"
    
    PKG_CONFIG_PATH=''

    # https://stackoverflow.com/questions/32826175/ftello-and-fseeko-android-build-errors
    # int fseeko(FILE* __fp, off_t __offset, int __whence) __RENAME(fseeko64) __INTRODUCED_IN(24);
    # off_t ftello(FILE* __fp) __RENAME(ftello64) __INTRODUCED_IN(24);
    if [ $MIN_SDK_API_LEVEL -lt 24 ] ; then
        CPPFLAGS="$CPPFLAGS -Dftello=ftell -Dfseeko=fseek"
    fi

    unset DEPENDENCY_PACKAGE_LIST
    resolve_DEPENDENCY_PACKAGE_LIST_of_a_package "$1"

    for PACKAGE in $DEPENDENCY_PACKAGE_LIST
    do
        PKG=$(printf "$PACKAGE" | tr '-' '_')
        
        PACKAGE_INSTALL_DIR="$MY_INSTALL_DIR/$PACKAGE/$BUILD_FOR_ABI"
        PACKAGE_INCLUDE_DIR="$PACKAGE_INSTALL_DIR/include"
        PACKAGE_LIBRARY_DIR="$PACKAGE_INSTALL_DIR/lib"

        eval "${PKG}_INSTALL_DIR='$PACKAGE_INSTALL_DIR'"
        eval "${PKG}_INCLUDE_DIR='$PACKAGE_INCLUDE_DIR'"
        eval "${PKG}_LIBRARY_DIR='$PACKAGE_LIBRARY_DIR'"

        CPPFLAGS="-I$PACKAGE_INCLUDE_DIR $CPPFLAGS"
         LDFLAGS="-L$PACKAGE_LIBRARY_DIR $LDFLAGS"
        PKG_CONFIG_PATH="$PKG_CONFIG_PATH:$PACKAGE_LIBRARY_DIR/pkgconfig"
    done

    if [ "$VERBOSE" = 'true' ] ; then
        CFLAGS="$CFLAGS -v"
        if [ -n "$MAKE" ] ; then
            MAKE="$MAKE --debug"
        fi
    fi

    PKG_INSTALL_DIR="$MY_INSTALL_DIR/$1"
    ABI_INSTALL_DIR="$PKG_INSTALL_DIR/$BUILD_FOR_ABI"
    
    if [ -n "$WORKING_DIR" ] ; then
        [ -d "$WORKING_DIR" ] || die "WORKING_DIR=[$WORKING_DIR] is not exist."
        BUILD_DIR="$WORKING_DIR/$TIMESTAMP_UNIX/$BUILD_FOR_ABI"
        mkdir -p "$BUILD_DIR"
    fi
}

export_vars() {
    export CC="$CC"
    export CXX="$CXX"
    export CPP="$CPP"
    export AR="$AR"
    export AS="$AS"
    export LD="$LD"
    export NM="$NM"
    export RANLIB="$RANLIB"
    export STRIP="$STRIP"

    export CFLAGS="$CFLAGS"
    export CXXFLAGS="$CFLAGS"
    export CPPFLAGS="$CPPFLAGS"
    export LDFLAGS="$LDFLAGS"

    export PKG_CONFIG_PATH="$PKG_CONFIG_PATH"
    export PKG_CONFIG_LIBDIR="$MY_INSTALL_DIR"
    
    if [ "$VERBOSE" = 'true' ] ; then
        export PKG_CONFIG_DEBUG_SPEW=set
    fi
}

printf_vars() {
    print_seperator 'printf_vars start'

    info "BUILD_ROUND_NUM = $BUILD_ROUND_NUM"
    info "        PACKAGE = $1"
    info "DIRECT_DEP_PKGS = $(get_direct_dependency_package_list_of_a_package "$1")"
    info ""
    info "ANDROID_NDK_VER  = $ANDROID_NDK_VERSION"
    info "ANDROID_NDK_HOME = $ANDROID_NDK_HOME"
    info "TOOLCHAIN_DIR    = $TOOLCHAIN_DIR"
    info "              CC = $CC"
    info "             CXX = $CXX"
    info "             CPP = $CPP"
    info "              AR = $AR"
    info "              AS = $AS"
    info "              LD = $LD"
    info "              NM = $NM"
    info "          RANLIB = $RANLIB"
    info "           STRIP = $STRIP"
    info "         SYSROOT = $SYSROOT"
    info "      PKG_CONFIG = $PKG_CONFIG"
    info "            MAKE = $MAKE"
    info "           CMAKE = $CMAKE"
    info "           MESON = $MESON"
    info "           NINJA = $NINJA"
    info "           SHELL = $SHELL"
    info ""
    info "SYSTEM_INCLUDE_DIR = $SYSTEM_INCLUDE_DIR"
    info "SYSTEM_LIBRARY_DIR = $SYSTEM_LIBRARY_DIR"
    info ""
    info "MIN_SDK_API_LEVEL = $MIN_SDK_API_LEVEL"
    info ""
    info "TOOLCHAIN_NAME = $TOOLCHAIN_NAME"
    info "BUILD_FOR_HOST = $BUILD_FOR_HOST"
    info "BUILD_FOR_ARCH = $BUILD_FOR_ARCH"
    info "BUILD_FOR_ABI  = $BUILD_FOR_ABI"
    info ""
    info "CFLAGS"
    for item in $CFLAGS
    do
        echo "    $item"
    done
    info ""
    info "CXXFLAGS"
    for item in $CXXFLAGS
    do
        echo "    $item"
    done
    info ""
    info "CPPFLAGS"
    for item in $CPPFLAGS
    do
        echo "    $item"
    done
    info ""
    info "LDFLAGS"
    for item in $LDFLAGS
    do
        echo "    $item"
    done
    info ""
    info "PKG_CONFIG_PATH"
    for item in $(echo $PKG_CONFIG_PATH | tr ':' ' ')
    do
        echo "    $item"
    done
    info ""
    info "PKG_CONFIG_LIBDIR = $PKG_CONFIG_LIBDIR"
    info ""
    info "PATH"
    for item in $(echo $PATH | tr ':' ' ')
    do
        echo "    $item"
    done
    info ""
    info "WORKING_DIR = $WORKING_DIR"
    info " SOURCE_DIR = $SOURCE_DIR"
    info "  BUILD_DIR = $BUILD_DIR"
    info ""
    info "PKG_INSTALL_DIR = $PKG_INSTALL_DIR"
    info "ABI_INSTALL_DIR = $ABI_INSTALL_DIR"
    print_seperator 'printf_vars end'
}

print_seperator() {
    info "=========================================> $1"
}

# run in a subshell
configure() {
    die_if_command_not_found make

    if [ "$BUILD_ROUND_NUM" -eq 1 ] ; then
        # https://www.gnu.org/software/gettext/manual/html_node/config_002eguess.html
        # https://git.savannah.gnu.org/cgit/config.git/tree/
        if [ ! -f "$MY_CACHED_DIR/config/config.sub" ] ; then
            fetch "http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD" --output-name=config.sub --output-dir="$MY_CACHED_DIR/config" || return 1
        fi
        if [ ! -f "$MY_CACHED_DIR/config/config.guess" ] ; then
            fetch "http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD" --output-name=config.guess --output-dir="$MY_CACHED_DIR/config" || return 1
        fi

        find "$SOURCE_DIR" -name "config.sub"   -exec cp -v "$MY_CACHED_DIR/config/config.sub"   {} \; || return 1
        find "$SOURCE_DIR" -name "config.guess" -exec cp -v "$MY_CACHED_DIR/config/config.guess" {} \; || return 1
    fi

    print_seperator "config start"
    
    if "$SOURCE_DIR"/configure \
        --host="$BUILD_FOR_HOST" \
        --prefix="$ABI_INSTALL_DIR" \
        --disable-option-checking \
        --disable-rpath \
        --disable-debug \
        --disable-nls\
        --enable-largefile \
        --enable-static \
        --enable-shared \
        CC="$CC" \
        CFLAGS="$CFLAGS" \
        CXX="$CXX" \
        CXXFLAGS="$CXXFLAGS" \
        CPP="$CPP" \
        CPPFLAGS="$CPPFLAGS" \
        LDFLAGS="$LDFLAGS" \
        AR="$AR" \
        RANLIB="$RANLIB" \
        CC_FOR_BUILD="$CC_FOR_BUILD" \
        PKG_CONFIG_PATH="$PKG_CONFIG_PATH" \
        PKG_CONFIG_LIBDIR="$PKG_CONFIG_LIBDIR" \
        $@ ; then
        print_seperator "config success"
    else
        print_seperator "config failed"
        return 1
    fi

    print_seperator "clean start"
    if $MAKE clean ; then
        print_seperator "clean success"
    else
        print_seperator "clean failed"
        return 1
    fi

    print_seperator "build start"
    if $MAKE ; then
        print_seperator "build success"
    else
        print_seperator "build failed"
        return 1
    fi

    print_seperator "install start"
    if $MAKE install ; then
        print_seperator "install success"
    else
        print_seperator "install failed"
        return 1
    fi
}

# https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html#cross-compiling
# https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_ROOT_PATH.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_PREFIX_PATH.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_INSTALL_PREFIX.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html
# https://cmake.org/cmake/help/latest/variable/BUILD_SHARED_LIBS.html
# https://cmake.org/cmake/help/latest/command/enable_testing.html?highlight=build_testing
# run in a subshell
cmake() {
    die_if_command_not_found cmake
    die_if_command_not_found  make

    "$CMAKE" \
    -DCMAKE_VERBOSE_MAKEFILE=ON \
    -DCMAKE_COLOR_MAKEFILE=ON \
    -DCMAKE_TOOLCHAIN_FILE="$ANDROID_NDK_HOME/build/cmake/android.toolchain.cmake" \
    -DCMAKE_PREFIX_PATH="$MY_INSTALL_DIR" \
    -DCMAKE_FIND_ROOT_PATH="$MY_INSTALL_DIR" \
    -DCMAKE_INSTALL_PREFIX="$ABI_INSTALL_DIR" \
    -DCMAKE_BUILD_TYPE=Release \
    -DCMAKE_C_FLAGS="'$CFLAGS $CPPFLAGS $LDFLAGS'" \
    -DCMAKE_CXX_FLAGS="'$CFLAGS $CPPFLAGS $LDFLAGS'" \
    -DBUILD_SHARED_LIBS=OFF \
    -DBUILD_TESTING=OFF \
    -DANDROID_TOOLCHAIN=clang \
    -DANDROID_ABI="$BUILD_FOR_ABI" \
    -DANDROID_PLATFORM="$MIN_SDK_API_LEVEL" \
    -G "Unix Makefiles" \
    -Wno-dev \
    -S "$SOURCE_DIR" \
    -B "$BUILD_DIR" $@ &&
    $MAKE --directory="$BUILD_DIR" &&
    $MAKE --directory="$BUILD_DIR" install
}

# https://mesonbuild.com/Cross-compilation.html
# run in a subshell
meson() {
    die_if_command_not_found meson
    die_if_command_not_found ninja

    cat >> "$BUILD_DIR/cross-file" <<EOF
[host_machine]
system = 'android'
endian = 'little'
cpu_family = '$BUILD_FOR_CPU_FAMILY'
cpu = '$BUILD_FOR_CPU_NAME'

[binaries]
c = '$CC'
cpp = '$CXX'
ar = '$AR'
strip = '$STRIP'
cmake = '$CMAKE'
pkgconfig = '$PKG_CONFIG'

[properties]
c_args = $(to_meson_array $CFLAGS $CPPFLAGS)
c_link_args = $(to_meson_array $LDFLAGS)
cpp_args = $(to_meson_array $CXXFLAGS $CPPFLAGS)
cpp_link_args = $(to_meson_array $LDFLAGS)
pkg_config_libdir = '$PKG_CONFIG_LIBDIR'
EOF
    "$MESON" setup \
        --prefix="$ABI_INSTALL_DIR" \
        --buildtype=release \
        --backend=ninja \
        --cross-file="$BUILD_DIR/cross-file" \
        $@ "$BUILD_DIR" "$SOURCE_DIR" &&
    "$NINJA" -C "$BUILD_DIR" install
}

to_meson_array() {
    RESULT="[''"
    for item in $@
    do
        RESULT="$RESULT, '$item'"
    done
    RESULT="$RESULT]"
    echo "$RESULT"
}

########################################################################

ldd() {
    check_prerequisites

    die_if_package_is_not_installed "$1"
    die_if_abi_____is_not_supported "$2"
    [ -z "$3" ] && die "type is not specified."
    [ -z "$4" ] && die "name is not specified."

    case $2 in
        armeabi-v7a) TOOLCHAIN_NAME='arm-linux-androideabi' ;;
        arm64-v8a)   TOOLCHAIN_NAME='aarch64-linux-android' ;;
        x86)         TOOLCHAIN_NAME='i686-linux-android' ;;
        x86_64)      TOOLCHAIN_NAME='x86_64-linux-android' ;;
        *)           die "$2: abi is not supported."
    esac

    TOOLCHAIN_PREFIX="$TOOLCHAIN_DIR/bin/$TOOLCHAIN_NAME"
    READELF="$TOOLCHAIN_PREFIX-readelf"
    die_if_file_is_not_executable "$READELF"

    ldd_recursion() {
        die_if_package_is_not_installed "$1"
        die_if_abi_____is_not_supported "$2"
        [ -z "$3" ] && die "type is not specified."
        [ -z "$4" ] && die "name is not specified."

        FILE_PATH="$MY_INSTALL_DIR/$1/$2/$3/$4"
        [ -f "$FILE_PATH" ] || die "$FILE_PATH not exist."
        echo "$FILE_PATH"

        DLL=$("$READELF" -d "$FILE_PATH" | grep ".so" | sed 's/.*\[\(.*\)\].*/\1/')
        for item in $DLL
        do
            ldd_recursion $(read_ldd_cache $item)
        done
    }

    ldd_recursion "$1" "$2" "$3" "$4"
}

list_supported_abis() {
    print_list armeabi-v7a arm64-v8a x86 x86_64
}

list_supported_sdk_api_levels() {
    print_list 21 22 23 24 25 26 27 28 29
}

get_ndk_version_via_awk() {
    awk -F= '/Pkg.Revision/{print(substr($2, 2))}' "$ANDROID_NDK_HOME/source.properties"
}

get_ndk_version_via_cut() {
    grep "Pkg.Revision" "$ANDROID_NDK_HOME/source.properties" | cut -d " " -f3
}

get_ndk_version_via_sed() {
    grep "Pkg.Revision" "$ANDROID_NDK_HOME/source.properties" | "$SED" 's/Pkg\.Revision = \(.*\).*/\1/'
}

get_ndk_version_via_ruby() {
    ruby <<EOF
File.open(ENV['ANDROID_NDK_HOME'] + '/source.properties', 'r') {|f|
  f.each_line {|lineText|
    if (lineText =~ /Pkg.Revision =.*/)
        puts lineText.gsub('Pkg.Revision = ', '')
    end
  }
  f.close
}
EOF
}

get_ndk_version_via_perl() {
    perl << EOF
open(DATA, "<$ANDROID_NDK_HOME/source.properties") or die "$ANDROID_NDK_HOME/source.propertiesæ–‡ä»¶æ— æ³•æ‰“å¼€, $!";
while(<DATA>) {
    if ("\$_" =~ m/Pkg.Revision/) {
        print substr("\$_", 15);
    }
}
EOF
}

get_ndk_version_via_python() {
    "$PYTHON" << EOF
import re;
file = open("$ANDROID_NDK_HOME/source.properties");
lines = file.readlines();
for line in lines:
    if -1 != line.find("Pkg.Revision"):
        print(re.findall("[0-9]{1,2}\.[0-9]{1,2}\.[0-9]{1,7}", line)[0]);
EOF
}

get_ndk_version_via_nodejs() {
    node << EOF
const fs = require('fs');

const buffer = fs.readFileSync("$ANDROID_NDK_HOME/source.properties");
if (buffer instanceof Error) {
    console.log(buffer);
    process.exit(1);
}

const text = buffer.toString();
const lines = text.split('\n');
lines.forEach((line, index, lines) => {
    const matched = line.match(/\d+\.\d+\.\d+/);
    if (matched) {
        console.log(matched[0]);
    }
});
EOF
}

get_ndk_version() {
    command -v cut  > /dev/null && get_ndk_version_via_cut    && return 0 
    command -v awk  > /dev/null && get_ndk_version_via_awk    && return 0
    command -v ruby > /dev/null && get_ndk_version_via_ruby   && return 0 
    command -v perl > /dev/null && get_ndk_version_via_perl   && return 0    
    command -v node > /dev/null && get_ndk_version_via_nodejs && return 0
    
    SED=$(command -v gsed) ||
    SED=$(command -v  sed)
    [ -z "$SED" ] || get_ndk_version_via_sed && return 0
     
    PYTHON=$(command -v python3) ||
    PYTHON=$(command -v python)  ||
    PYTHON=$(command -v python2) 
    [ -z "$PYTHON" ] || get_ndk_version_via_python && return 0
}

get_ndk_version_major() {
    command -v cut > /dev/null && printf "$ANDROID_NDK_VERSION" | cut -d. -f1          && return 0
    command -v awk > /dev/null && printf "$ANDROID_NDK_VERSION" | awk -F. '{print $1}' && return 0
    command -v sed > /dev/null && printf "$ANDROID_NDK_VERSION" | sed 's/\..*//g'      && return 0
    echo 0
}

check_prerequisites() {
    [ -z "$ANDROID_NDK_ROOT" ] || export ANDROID_NDK_HOME="$ANDROID_NDK_ROOT"
    [ -z "$ANDROID_NDK_HOME" ] && die "please set and export ANDROID_NDK_HOME=DIR environment variable, then try again!"
    [ -d "$ANDROID_NDK_HOME" ] || die "ANDROID_NDK_HOME=$ANDROID_NDK_HOME is not a valid directory!"
    
    TOOLCHAIN_DIR="$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/$BUILD_MACHINE_OS-$(uname -m)"
    SYSROOT="$TOOLCHAIN_DIR/sysroot"

    ANDROID_NDK_VERSION="$(get_ndk_version)"
    ANDROID_NDK_VERSION_MAJOR="$(get_ndk_version_major)"

    # Android NDK version must be r19 or newer.
    if [ "$ANDROID_NDK_VERSION_MAJOR" -lt 19 ] ; then
        die "your installed android-ndk [$ANDROID_NDK_HOME] version is $ANDROID_NDK_VERSION, please update to r19 or newer."
    fi

    export PATH="$ANDROID_NDK_HOME:$PATH"
}

parse_arguments() {
    # https://developer.android.google.cn/guide/topics/manifest/uses-sdk-element#api-level-table
    unset MIN_SDK_API_LEVEL

    unset TO_BE_INSTALLED_PACKAGE_LIST

    unset DRYRUN
    unset XTRACE
    unset VERBOSE

    unset KEEP_WORKING_DIR
    
    shift
    
    while test -n "$1"
    do
        case "$1" in
            --min-sdk-api-level=[1-9][0-9])
                MIN_SDK_API_LEVEL=$(getvalue "$1")
                ;;
            --verbose|-v)
                VERBOSE=true
                ;;
            --xtrace|-x)
                XTRACE=true
                set -x
                ;;
            --dry-run)
                DRYRUN=true
                ;;
            --keep-working-dir)
                KEEP_WORKING_DIR=true
                ;;
            [a-z]*)
                if [ -z "$TO_BE_INSTALLED_PACKAGE_LIST" ] ; then
                    TO_BE_INSTALLED_PACKAGE_LIST="$1"
                else
                    TO_BE_INSTALLED_PACKAGE_LIST="$TO_BE_INSTALLED_PACKAGE_LIST $1"
                fi
                ;;
            *)  die "$1 is a invalid argument."
        esac
        shift
    done

    [ -z "$MIN_SDK_API_LEVEL" ] && {
        MIN_SDK_API_LEVEL=$(list_supported_sdk_api_levels | head -n 1)
        warn "--min-sdk-api-level=INTEGER argument is not specified. so, use the default value [$MIN_SDK_API_LEVEL]."
    }

    BUILD_FOR_ABI_LIST="$(list_supported_abis)"
    BUILD_LIST="$BUILD_FOR_ABI_LIST"
}

help() {
    cat << EOF
$MY_NAME is a package manager for Android NDK to build C/C++ project.

Usage: $MY_NAME <ACTION> [ARGUMENT...]

ACTION:
    help    | --help    | -h    --show help information.
    version | --version | -V    --print version of $MY_NAME and Android NDK.
    
    list supported-abis              --list the supported abis.
    list supported-sdk-api-levels    --list the supported android-sdk api-levels.
    
    list available         --list the available packages.
    list installed         --list the installed packages.
    list outdated          --list the outdated packages.

    is available PACKAGE  --is PACKAGE available?
    is installed PACKAGE  --is PACKAGE installed?
    is outdated  PACKAGE  --is PACKAGE outdated?
    
    search KEYWORD        --search packages.
    
    formula create PACKAGE   --create a new formula.
    formula delete PACKAGE   --delete a exist formula.
    formula rename P1 P2     --rename a exist formula to new name.
    formula view PACKAGE     --view the formula of a package.
    formula edit PACKAGE     --edit the formula of a package.
    formula list             --equipment to list available

    tree PACKAGE          --list contents of a installed package directory in a tree-like format.
    pack PACKAGE          --pack a installed package.
    logs PACKAGE ABI      --print the logs of a installed package.
    info PACKAGE...       --print the information of packages.
    fetch PACKAGE         --download formula resources of a package to the cache.
    prefix PACKAGE        --show the installation direcotory of a formula or the $MY_NAME home.
    homepage PACKAGE      --visit the homepage of a formula or the $MY_NAME project.

    install   PACKAGE... [--min-sdk-api-level=21 -v -x --dry-run]     --install packages.
    reinstall PACKAGE... [--min-sdk-api-level=21 -v -x --dry-run]     --reinstall packages.
    upgrade   PACKAGE... [--min-sdk-api-level=21 -v -x --dry-run]     --upgrade packages.
    uninstall PACKAGE...   --uninstall packages.
    
    cleanup          --cleanup the unused cache.
    update           --update the formula repository.
EOF
    if [ -z "$1" ] ; then
        exit
    else
        exit "$1"
    fi
}

init() {
    # MY represents this software's
    MY_NAME=ndk-pkg
    MY_VERSION=0.1.0
    MY_HOME_PAGE="https://github.com/leleliu008/$MY_NAME"

    if [ -z "$NDK_PKG_FORMULA_REPO_URL" ] ; then
        MY_FORMULA_REPO_URL="https://github.com/leleliu008/$MY_NAME-formula.git"
    else
        MY_FORMULA_REPO_URL="$NDK_PKG_FORMULA_REPO_URL"
    fi

    if [ -z "$NDK_PKG_HOME_DIR" ] ; then
        MY_HOME_DIR="$HOME/.$MY_NAME"
    else
        MY_HOME_DIR="$NDK_PKG_HOME_DIR"
    fi

    MY_FORMULA_DIR="$MY_HOME_DIR/formula"
    MY_INSTALL_DIR="$MY_HOME_DIR/pkg"
    MY_CACHED_DIR="$MY_HOME_DIR/downloads"
    MY_BOTTLE_DIR="$MY_HOME_DIR/bottles"
    MY_BACKUP_DIR="$MY_HOME_DIR/backup"

    if command -v date > /dev/null ; then
        TIMESTAMP_UNIX="$(date +%s)"
    else
        die "command not found: date. please make sure it in PATH."
    fi

    if command -v uname > /dev/null ; then
        if command -v tr > /dev/null ; then
            BUILD_MACHINE_OS="$(uname -s | tr A-Z a-z)"
        elif command -v  awk > /dev/null ; then
            BUILD_MACHINE_OS="$(uname -s |  awk '{print(tolower($0))}')"
        elif command -v gawk > /dev/null ; then
            BUILD_MACHINE_OS="$(uname -s | gawk '{print(tolower($0))}')"
        else
            die "please install GNU CoreUtils or awk."
        fi
        case $BUILD_MACHINE_OS in
            msys*|mingw*|cygwin*) BUILD_MACHINE_OS=windows
        esac
    else
        die "command not found: uname. please make sure it in PATH."
    fi
}

main() {
    init

    case $1 in
        --help|help|-h) 
            help
            ;;
        --version|version|-V)
            echo "$MY_NAME $MY_VERSION"
            check_prerequisites
            echo "NDK     $ANDROID_NDK_VERSION"
            ;;
        list)
            shift
            case "$1" in
                abis)
                    shift
                    list_supported_abis
                    ;;
                sdk-api-levels)
                    shift
                    list_supported_sdk_api_levels
                    ;;
                available) shift; list_available_packages ;;
                installed) shift; list_installed_packages ;;
                outdated)  shift; list__outdated_packages ;;
                *) help 1
            esac
            ;;
        search)  shift; search_packages "$*" ;;
        formula) shift
            case $1 in
                create) shift; create_a_formula "$@" ;;
                delete) shift; delete_a_formula "$@" ;;
                rename) shift; rename_a_formula "$@" ;;
                view)   shift; view_a_formula   "$@" ;;
                edit)   shift; edit_a_formula   "$@" ;;
                list)   shift; list_available_packages ;;
                   *)   help 1
            esac
            ;;
        update)  update_formula_repository ;;
        cleanup) cleanup ;;

        install)     install_packages "$@" ;;
        reinstall) reinstall_packages "$@" ;;
        uninstall) uninstall_packages "$@" ;;
        upgrade)     upgrade_packages "$@" ;;

        homepage) shift; open_homepage_of_a_package "$@" ;;
        prefix) shift; print_prefix_of_a_package "$@" ;;
        fetch) shift; fetch_a_package "$@" ;;
        logs)  shift; logs_a_package  "$@" ;;
        pack)  shift; pack_a_package  "$@" ;;
        tree)  shift; tree_a_package  "$@" ;;
        info)  shift; info_packages "$@" ;;
        is)
            shift
            case $1 in
                available) shift; is_package_available "$@" ;;
                installed) shift; is_package_installed "$@" ;;
                outdated)  shift; is_package__outdated "$@" ;;
                *) help 1
            esac
            ;;
        ldd) shift; ldd "$@" ;;
        *)   help 1
    esac
}

main "$@"