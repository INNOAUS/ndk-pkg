#!/bin/sh

#------------------------------------------------------------------------------
# https://developer.android.google.cn/ndk/guides/other_build_systems
# https://clang.llvm.org/docs/CrossCompilation.html
# 
#------------------------------------------------------------------------------

COLOR_RED='\033[0;31m'          # Red
COLOR_GREEN='\033[0;32m'        # Green
COLOR_YELLOW='\033[0;33m'       # Yellow
COLOR_BLUE='\033[0;34m'         # Blue
COLOR_PURPLE='\033[0;35m'       # Purple
COLOR_OFF='\033[0m'             # Reset

print() {
    printf "%b" "$*"
}

echo() {
    print "$*\n"
}

info() {
    print "${COLOR_PURPLE}$*\n${COLOR_OFF}"
}

success() {
    print "${COLOR_GREEN}[âœ”] $*\n${COLOR_OFF}"
}

warn() {
    print "${COLOR_YELLOW}ðŸ”¥ $*\n${COLOR_OFF}"
}

error() {
    print "${COLOR_RED}[âœ˜] $*\n${COLOR_OFF}"
}

die() {
    print "${COLOR_RED}[âœ˜] $*\n${COLOR_OFF}"
    exit 1
}

list() {
    for item in $@
    do
        echo "$item"
    done
}

list_length() {
    echo $#
}

nproc() {
    if command nproc --version > /dev/null 2>&1 ; then
        command nproc
    elif test -f /proc/cpuinfo ; then
        grep -c processor /proc/cpuinfo
    elif command -v sysctl > /dev/null ; then
        sysctl -n machdep.cpu.thread_count
    else
        echo 4
    fi
}

sed_in_place() {
    if command -v gsed > /dev/null ; then
        gsed -i "$1" "$2"
    elif command -v sed  > /dev/null ; then
        sed -i    "$1" "$2" 2> /dev/null || 
        sed -i "" "$1" "$2"
    else
        die "please install sed utility."
    fi
}

trim() {
    if [ $# -eq 0 ] ; then
        sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//'
    else
        if [ -n "$*" ] ; then
            echo "$*" | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//'
        fi
    fi
}

tolower() {
    if [ $# -eq 0 ] ; then
        if command -v tr > /dev/null ; then
            tr A-Z a-z
        elif command -v  awk > /dev/null ; then
            awk '{print(tolower($0))}'
        elif command -v gawk > /dev/null ; then
            gawk '{print(tolower($0))}'
        else
            die "please install GNU CoreUtils or awk."
        fi
    else
        if [ -z "$*" ] ; then
            return 0
        fi
        if command -v tr > /dev/null ; then
            echo "$*" | tr A-Z a-z
        elif command -v  awk > /dev/null ; then
            echo "$*" | awk '{print(tolower($0))}'
        elif command -v gawk > /dev/null ; then
            echo "$*" | gawk '{print(tolower($0))}'
        elif command -v python > /dev/null ; then
            python  -c 'import sys; print(sys.argv[1].lower());' "$*"
        elif command -v python3 > /dev/null ; then
            python3 -c 'import sys; print(sys.argv[1].lower());' "$*"
        elif command -v python2 > /dev/null ; then
            python2 -c 'import sys; print(sys.argv[1].lower());' "$*"
        elif command -v perl > /dev/null ; then
            perl -e 'print @ARGV[0],"\n"' "$1"
        elif command -v node > /dev/null ; then
            node -e 'console.log(process.argv[2].toLowerCase())' - "$*"
        else
            die "please install GNU CoreUtils or awk."
        fi
    fi
}

format_unix_timestamp() {
   date -jf "%s" "$1" "$2" 2> /dev/null ||
   date -d      "@$1" "$2"
}

getvalue() {
    if [ $# -eq 0 ] ; then
        cut -d= -f2
    else
        echo "$1" | cut -d= -f2
    fi
}

eeval() {
    echo "$COLOR_PURPLE==>$COLOR_OFF $COLOR_GREEN$@$COLOR_OFF"
    eval "$@"
}

run() {
    echo "$COLOR_PURPLE==>$COLOR_OFF $COLOR_GREEN$@$COLOR_OFF"
    $@
}

prompt_user_to_install_bat() {
    warn "if you want to have a better experience, I strongly recommend you install ${COLOR_RED}bat${COLOR_OFF} on your os. For more details, see ${COLOR_RED}https://github.com/sharkdp/bat${COLOR_OFF}"
}

__fetch_via_git() {
    if [ -d "$FETCH_OUTPUT_PATH" ] ; then
        if      git -C "$FETCH_OUTPUT_PATH" rev-parse 2> /dev/null ; then
            run git -C "$FETCH_OUTPUT_PATH" pull &&
            run git -C "$FETCH_OUTPUT_PATH" submodule update --recursive
        else
            run rm -rf "$FETCH_OUTPUT_PATH" &&
            run git -C "$FETCH_OUTPUT_DIR" clone --recursive "$FETCH_URL" "$FETCH_OUTPUT_NAME"
        fi
    else
        run git -C "$FETCH_OUTPUT_DIR" clone --recursive "$FETCH_URL" "$FETCH_OUTPUT_NAME"
    fi
}

__fetch_archive_via_tools() {
    if [ -f "$FETCH_OUTPUT_PATH" ] ; then
        if [ -n "$FETCH_SHA256" ] ; then
            if is_sha256sum_match "$FETCH_OUTPUT_PATH" "$FETCH_SHA256" ; then
                success "$FETCH_OUTPUT_PATH already have been downloaded."
                return 0
            fi
        fi
        rm -f "$FETCH_OUTPUT_PATH"
    fi

    if command -v curl > /dev/null ; then
        run curl --fail --retry 20 --retry-delay 30 --location -o "$FETCH_OUTPUT_PATH" "$FETCH_URL"
    elif command -v wget > /dev/null ; then
        run wget --timeout=60 -O "$FETCH_OUTPUT_PATH" "$FETCH_URL"
    elif command -v http > /dev/null ; then
        run http --timeout=60 -o "$FETCH_OUTPUT_PATH" "$FETCH_URL"
    elif command -v lynx > /dev/null ; then
        run lynx -source "$FETCH_URL" > "$FETCH_OUTPUT_PATH"
    elif command -v aria2c > /dev/null ; then
        run aria2c -d "$FETCH_OUTPUT_DIR" -o "$FETCH_OUTPUT_NAME" "$FETCH_URL"
    elif command -v axel > /dev/null ; then
        run axel -o "$FETCH_OUTPUT_PATH" "$FETCH_URL"
    else
        die "please install curl or wget."
    fi

    if [ $? -eq 0 ] ; then
        success "Fetched to $FETCH_OUTPUT_PATH success."
    else
        die "Fetched to $FETCH_OUTPUT_PATH failed."
    fi

    if [ -n "$FETCH_SHA256" ] ; then
        die_if_sha256sum_mismatch "$FETCH_OUTPUT_PATH" "$FETCH_SHA256"
    fi
}

# fetch <URL> [--sha256=SHA256] <--output-path=PATH>
# fetch <URL> [--sha256=SHA256] <--output-dir=DIR> <--output-name=NAME>
# fetch <URL> [--sha256=SHA256] <--output-dir=DIR> [--output-name=NAME]
# fetch <URL> [--sha256=SHA256] [--output-dir=DIR] <--output-name=NAME>
fetch() {
    unset FETCH_URL
    unset FETCH_SHA256
    unset FETCH_OUTPUT_DIR
    unset FETCH_OUTPUT_NAME
    unset FETCH_OUTPUT_PATH
    
    if [ -z "$1" ] ; then
        die "please specify a fetch url."
    else
        FETCH_URL="$1"
    fi
    
    shift
    
    while [ -n "$1" ]
    do
        case $1 in
            --sha256=*)
                FETCH_SHA256=$(getvalue "$1")
                ;;
            --output-dir=*)
                FETCH_OUTPUT_DIR=$(getvalue "$1")
                if [ -z "$FETCH_OUTPUT_DIR" ] ; then
                    die "--output-dir argument's value must be not empty."
                fi
                ;;
            --output-name=*)
                FETCH_OUTPUT_NAME=$(getvalue "$1")
                if [ -z "$FETCH_OUTPUT_NAME" ] ; then
                    die "--output-name argument's value must be not empty."
                fi
                ;;
            --output-path=*)
                FETCH_OUTPUT_PATH=$(getvalue "$1")
                if [ -z "$FETCH_OUTPUT_PATH" ] ; then
                    die "--output-path argument's value must be not empty."
                fi
        esac
        shift
    done
    
    if [ -z "$FETCH_OUTPUT_PATH" ] ; then
        [ -z "$FETCH_OUTPUT_DIR" ]  && FETCH_OUTPUT_DIR="$PWD"
        [ -z "$FETCH_OUTPUT_NAME" ] && FETCH_OUTPUT_NAME=$(basename "$FETCH_URL")

        FETCH_OUTPUT_PATH="$FETCH_OUTPUT_DIR/$FETCH_OUTPUT_NAME"
    else
        FETCH_OUTPUT_DIR="$(dirname $FETCH_OUTPUT_PATH)"
        FETCH_OUTPUT_NAME="$(basename $FETCH_OUTPUT_PATH)"
    fi

    install -v -d "$FETCH_OUTPUT_DIR"

    case $FETCH_URL in
        *.git) __fetch_via_git ;;
        *)     __fetch_archive_via_tools ;;
    esac
}

sha256sum() {
    die_if_file_is_not_exist "$1"

    if command -v openssl > /dev/null ; then
        openssl sha256 "$1" | awk '{print $2}'
    elif command sha256sum --version > /dev/null 2>&1 ; then
        sha256sum "$1" | awk '{print $1}'
    else
        die "please install openssl or GNU CoreUtils."
    fi
}

is_sha256sum_match() {
    die_if_file_is_not_exist "$1"
    [ -z "$2" ] && die "please specify sha256sum."
    [ "$(sha256sum $1)" = "$2" ]
}

die_if_sha256sum_mismatch() {
    is_sha256sum_match "$1" "$2" || die "sha256sum mismatch."
}

__fetch_sources_of_a_package() {
    # fetch source code if posible
    if [ "$PACKAGE_SRC_TYPE" != 'dir' ] ; then
        fetch "$PACKAGE_SRC_URL" --sha256="$PACKAGE_SRC_SUM" --output-path="$PACKAGE_SRC_PATH"
    fi
}

__fetch_patches_of_a_package() {
    unset PACKAGE_PATCHES

    # fetch patches if posible
    while [ -n "$1" ]
    do
        fetch "$1" --sha256="$2" --output-dir="$MY_PATCH_DIR/$PACKAGE_NAME" --output-name="$(basename $1)"
        
        if [ -z "$PACKAGE_PATCHES" ] ; then
            PACKAGE_PATCHES="$FETCH_OUTPUT_PATH"
        else
            PACKAGE_PATCHES="$PACKAGE_PATCHES $FETCH_OUTPUT_PATH"
        fi

        shift 2
    done
}

__fetch_resources_of_a_package() {
    ___load_formula_of_a_package "$1"

    __fetch_sources_of_a_package

    __fetch_patches_of_a_package $PACKAGE_PATCHES
}

die_if_file_is_not_exist() {
    [ -z "$1" ] && die "please specify a file path."
    [ -f "$1" ] || die "$1 is not exist."
}

die_if_file_is_not_executable() {
    die_if_file_is_not_exist "$1"
    [ -x "$1" ] || die "$1 is not executable."
}

die_if_abi_____is_not_specified() {
    [ -z "$1" ] && die "please specify a abi."
}

die_if_abi_____is_not_supported() {
    die_if_abi_____is_not_specified "$1"
    
    for ABI in $(__list_supported_abis)
    do
        [ "$ABI" = "$1" ] && return 0
    done

    die "$1 abi is not supported."
}

die_if_package_is_not_specified() {
    [ -z "$1" ] && die "please specify a package name."
}

die_if_package_list_is_not_specified() {
    [ -z "$1" ] && die "please specify at least one package name."
}

die_if_package_is_not_available() {
    is_package_available "$1" || die "$1 is not available."
}

die_if_package_is_already_exist() {
    die_if_package_is_not_specified "$1"
    [ -f "$MY_FORMULA_DIR/$1.sh" ] && die "$1 package is already exist."
}

die_from_package_is_not_installed() {
    die "$1 is not installed."
}

die_if_package_is_not_installed() {
    is_package_installed "$1" || die_from_package_is_not_installed "$1"
}

is_package_available() {
    die_if_package_is_not_specified "$1"
    [ -f "$MY_FORMULA_DIR/$1.sh" ]
}

is_package_installed() {
    die_if_package_is_not_specified "$1"
    
    [ -d "$MY_INSTALL_DIR/$1" ]              || return 1
    [ -f "$MY_INSTALL_DIR/$1/manifest.txt" ] || return 1

    for ABI in $(cat "$MY_INSTALL_DIR/$1/manifest.txt")
    do
        [ -d "$MY_INSTALL_DIR/$1/$ABI" ]                       || return 1
        [ -d "$MY_INSTALL_DIR/$1/$ABI/log" ]                   || return 1
        [ -f "$MY_INSTALL_DIR/$1/$ABI/log/installed.log.txt" ] || return 1
    done
}

is_package__outdated() {
    ___load_formula_of_a_package "$1"

    [ -d "$MY_INSTALL_DIR/$1" ]              || die_from_package_is_not_installed "$1"
    [ -f "$MY_INSTALL_DIR/$1/manifest.txt" ] || die_from_package_is_not_installed "$1"

    for ABI in $(cat "$MY_INSTALL_DIR/$1/manifest.txt")
    do
        [ -d "$MY_INSTALL_DIR/$1/$ABI" ]                       || die_from_package_is_not_installed "$1"
        [ -d "$MY_INSTALL_DIR/$1/$ABI/log" ]                   || die_from_package_is_not_installed "$1"
        [ -f "$MY_INSTALL_DIR/$1/$ABI/log/installed.log.txt" ] || die_from_package_is_not_installed "$1"
        die_if_load_installed_log_failed "$1" "$ABI"
        [ "$PACKAGE_VERSION" = "$installed_pkg_version" ] && return 1
        [ "$PACKAGE_VERSION" = $(printf "$PACKAGE_VERSION\n$installed_pkg_version" | sort --version-sort --reverse | head -n 1) ]
    done
}

__list_packages_which_is_not_depended_by_others() {
    unset BREAK
    unset NDEPENDED_PACKAGES
    unset AVAILABLE_PACKAGES

    AVAILABLE_PACKAGES=$(__list_available_packages)

    for x in $AVAILABLE_PACKAGES
    do
        if [ "$x" = 'test' ] ; then
            continue
        fi
        for y in $AVAILABLE_PACKAGES
        do
            if [ "$x" = "$y" ] || [ 'test' = "$y" ] ; then
                continue
            else
                ___load_formula_of_a_package "$y"
                for z in $PACKAGE_DEPENDS
                do
                    if [ "$x" = "$z" ] ; then
                        BREAK=true
                        break 2
                    fi
                done
            fi
        done
        if [ "$BREAK" = 'true' ] ; then
            unset BREAK
        else
            if [ -z "$NDEPENDED_PACKAGES" ] ; then
                NDEPENDED_PACKAGES="$x"
            else
                NDEPENDED_PACKAGES="$NDEPENDED_PACKAGES $x"
            fi
            if [ "$(list_length $NDEPENDED_PACKAGES)" -eq 20 ] ; then
                echo "$NDEPENDED_PACKAGES" | tr ' ' ,
                echo
                unset NDEPENDED_PACKAGES
            fi
        fi
    done
    if [ -n "$NDEPENDED_PACKAGES" ] ; then
        echo "$NDEPENDED_PACKAGES" | tr ' ' ,
    fi
}

__list_available_packages() {
    unset SILENT

    case $# in
        0)  ;;
        1)  if [ "$1" = '-q' ] ; then
                SILENT=true
            else
                die "list available action only accept -q argument."
            fi
            ;;
        *)  die "list available action only accept -q argument."
    esac

    [ -d "$MY_FORMULA_DIR" ] || {
        if [ "$SILENT" = 'true' ] ; then
            __update_formula_repository >/dev/null 2>&1
        else
            __update_formula_repository
        fi
    }
    
    if [ "$SILENT" = 'true' ] ; then
        cd "$MY_FORMULA_DIR" 2>/dev/null || exit 1
    else
        cd "$MY_FORMULA_DIR" || exit 1
    fi

    for item in $(ls *.sh | sed 's/\.sh//g')
    do
        echo "$item"
    done
}

__list_installed_packages() {
    if [ -d "$MY_INSTALL_DIR" ] ; then
         cd "$MY_INSTALL_DIR" 2>/dev/null || return 1
    else
        return 0
    fi

    for packageName in *
    do
        if is_package_installed "$packageName" ; then
            echo "$packageName"
        fi
    done
}

__list__outdated_packages() {
    if [ -d "$MY_INSTALL_DIR" ] ; then
         cd "$MY_INSTALL_DIR" 2>/dev/null || return 1
    else
        return 0
    fi

    for packageName in *
    do
        is_package_available "$packageName" || continue
        is_package_installed "$packageName" || continue
        is_package__outdated "$packageName" || continue
        echo "$packageName"
    done
}

__list_abis_of_a_installed_package() {
    die_if_package_is_not_installed "$1"
    cat "$MY_INSTALL_DIR/$1/manifest.txt"
}

__tree_installed_of_a_package() {
    die_if_package_is_not_installed "$1"

    PKG_INSTALL_DIR="$MY_INSTALL_DIR/$1"

    shift

    if command -v tree > /dev/null ; then
        run tree $@ --dirsfirst "$PKG_INSTALL_DIR"
    else
        warn "please install tree utility."
    fi
}

__uninstall_packages() {
    shift

    die_if_package_list_is_not_specified "$1"
    
    for packageName in $@
    do
        __uninstall_a_package "$packageName" || return 1
    done
}

__uninstall_a_package() {
    die_if_package_is_not_installed "$1"

    run rm -rf "$MY_INSTALL_DIR/$1"
}

____view_a_formula() {
    die_if_package_is_not_available "$1"

    [ -z "$2" ] || warn "view action accept only one argument."
    
    if command -v bat > /dev/null ; then
        bat "$MY_FORMULA_DIR/$1.sh"
    else
        cat "$MY_FORMULA_DIR/$1.sh"
        echo
        prompt_user_to_install_bat
    fi    
}

____edit_a_formula() {
    die_if_package_is_not_available "$1"

    [ -z "$2" ] || warn "edit action accept only one argument."

    [ -z "$EDITOR" ] &&
    EDITOR=$(command -v nvim) ||
    EDITOR=$(command -v vim) ||
    EDITOR=$(command -v vi) ||
    EDITOR=$(command -v open) ||
    die "please set EDITOR environment variable."

    "$EDITOR" "$MY_FORMULA_DIR/$1.sh"
}

__create_a_formula() {
    die_if_package_is_already_exist "$1"

    cat > "$MY_FORMULA_DIR/$1.sh" <<EOF
summary "Summary of this package"

webpage "https://www.xx.com"

# the source code download url of this package. the value of src_url must end with one of .git .zip .tar.xz .tar.gz .tar.lz .tar.bz2 .tgz .txz
src_url "https://www.xx.com/pkgname-x.y.z.tar.gz"

# the sha256sum of source code. If the value of src_url end with .git, this function is optional, otherwise, this function must be invoked.
src_sum "c3e5e9fdd5004dcb542feda5ee4f0ff0744628baf8ed2dd5d66f8ca1197cb1a1"

# the version of this package. If this function is not invoked, it will be calculated from src_url.
#version "x.y.z"

# the license of this package.
#license "MIT"

# the required commands of this package when installing. If specify multiple values, separate them with spaces.
#require "a b c"

# the packages are depended by this package. If specify multiple values, separate them with spaces.
#depends "a b c"

prepare() {
    :
    #this function is optional, you can delete it, if don't use it.
}

build() {
    :
    #configure
    #cmake
    #meson
    #cargo
    #go
    #make
}
EOF
    ____edit_a_formula "$1"
}

__delete_a_formula() {
    die_if_package_is_not_available "$1"

    if rm "$MY_FORMULA_DIR/$1.sh" ; then
        success "delete $1 formula success."
    else
        die "delete $1 formula failed."
    fi
}

__rename_a_formula() {
    die_if_package_is_not_available "$1"
    die_if_package_is_already_exist "$2"

    if mv "$MY_FORMULA_DIR/$1.sh" "$MY_FORMULA_DIR/$2.sh" ; then
        success "rename formula $1 -> $2 success."
    else
        die "rename formula $1 -> $2 failed."
    fi
}

__update_formula_repository() {
    fetch "$MY_FORMULA_REPO_URL" --output-dir="$MY_HOME_DIR" --output-name=formula
}

____upgrade_packages() {
    check_prerequisites
    parse_arguments "$@"

    [ -z "$USER_SPECIFIED_PACKAGE_LIST" ] && USER_SPECIFIED_PACKAGE_LIST=$(__list__outdated_packages)
    [ -z "$USER_SPECIFIED_PACKAGE_LIST" ] && return 0

    __reinstall_packages
}

__reinstall_packages() {
    check_prerequisites
    parse_arguments "$@"

    die_if_package_list_is_not_specified "$USER_SPECIFIED_PACKAGE_LIST"

    for packageName in $USER_SPECIFIED_PACKAGE_LIST
    do
        die_if_package_is_not_available "$packageName"
        die_if_package_is_not_installed "$packageName"
    done
    
    for packageName in $USER_SPECIFIED_PACKAGE_LIST
    do
        {
            [ -d "$MY_BACKUP_DIR" ] || mkdir -p "$MY_BACKUP_DIR"
        } &&
        mv "$MY_INSTALL_DIR/$packageName" "$MY_BACKUP_DIR/$packageName" &&
        __install_a_package "$packageName" &&
        rm -rf "$MY_BACKUP_DIR/$packageName"
    done
}

__cleanup() {
    success "Done."
}

__search_packages() {
    [ -z "$1" ] && die "please specify a keyword."
    [ -d "$MY_FORMULA_DIR" ] || __update_formula_repository
    
    cd "$MY_FORMULA_DIR" || exit 1

    for item in $(ls -1 *.sh | sed 's/\.sh//g')
    do
        echo "$item" | grep "$*" || true
    done
}

__show_webpage_of_a_package() {
    if [ -z "$1" ] ; then
        PACKAGE_WEBPAGE="$MY_HOME_PAGE"
    else
        ___load_formula_of_a_package "$1"
    fi
    
    echo "$PACKAGE_WEBPAGE"

    if command -v open > /dev/null ; then
        open "$PACKAGE_WEBPAGE"
    fi
}

__show_depends_of_a_package() {
    die_if_package_is_not_specified "$1"

    EMPTY_DIR=$(mktemp -d) || return 1
    __gen_dependency_tree 'true' "$1"

    if [ -f "$DEPENDENCIES_TXT" ] ; then
        cat "$DEPENDENCIES_TXT"
    elif [ -f "$DEPENDENCIES_PNG" ] ; then
        if command -v open > /dev/null ; then
            open "$DEPENDENCIES_PNG"
        elif command -v feh > /dev/null ; then
            feh "$DEPENDENCIES_PNG"
        elif command -v eog > /dev/null ; then
            eog "$DEPENDENCIES_PNG"
        elif command -v lsix > /dev/null ; then
            lsix "$DEPENDENCIES_PNG"
        fi
    elif [ -f "$DEPENDENCIES__GV" ] ; then
        cat "$DEPENDENCIES__GV"
    fi
}

__show_prefix_of_a_package() {
    if [ -z "$1" ] ; then
        echo "$MY_HOME_DIR"
    else
        die_if_package_is_not_installed "$1"
        echo "$MY_INSTALL_DIR/$1"
    fi
}

__show_logs_of_a_package() {
    die_if_package_is_not_installed "$1"
    die_if_abi_____is_not_supported "$2"

    if command -v bat > /dev/null ; then
        VIEWER=bat
    else
        VIEWER=less
    fi

    for item in $(ls "$MY_INSTALL_DIR/$1/$2/log"/*)
    do
        if [ "$VIEWER" = 'bat' ] ; then
            case $item in
                *.png) ;;
                *.sh|*/installed.log.txt)
                    bat -l bash "$item" ;;
                *)  bat "$item"
            esac
        else
            "$VIEWER" "$item"
        fi
    done

    if [ "$VIEWER" != 'bat' ] ; then
        prompt_user_to_install_bat
    fi
}

__pack_bottle_of_a_package() {
    die_if_package_is_not_installed "$1"
    
    install -d "$MY_BOTTLE_DIR" || return 1

    if command -v zip > /dev/null ; then
        run cd "$MY_INSTALL_DIR" || return 1
        run zip -9 -r "$MY_BOTTLE_DIR/$1-bottle.zip" "$1"
    elif command -v tar > /dev/null ; then
        if command -v gzip > /dev/null ; then
            run tar zvcf "$MY_BOTTLE_DIR/$1-bottle.tar.gz" -C "$MY_INSTALL_DIR" "$1"
        elif command -v xz > /dev/null ; then
            run tar Jvcf "$MY_BOTTLE_DIR/$1-bottle.tar.xz" -C "$MY_INSTALL_DIR" "$1"
        elif command -v bzip2 > /dev/null ; then
            run tar jvcf "$MY_BOTTLE_DIR/$1-bottle.tar.bz2" -C "$MY_INSTALL_DIR" "$1"
        else
            die "please install gzip or xz or bzip2 utility."
        fi
    else
        die "please install zip or tar utility."
    fi
}

get_direct_dependency_package_list_of_a_package() {
    grep '^\s*depends\s*".*"' "$MY_FORMULA_DIR/$1.sh" | sed 's/.*depends.*"\(.*\)"/\1/'
}

# $1 is first call
# $2 packageName
__gen_dependency_list() {
    if [ "$1" = 'true' ] ; then
        unset I
        unset DEPENDENCY_PACKAGE_LIST
    fi

    unset DIRECT_DEPENDENCY_PACKAGE_LIST
    if [ -z "$2" ] ; then
        DIRECT_DEPENDENCY_PACKAGE_LIST="$USER_SPECIFIED_PACKAGE_LIST"
    else
        DIRECT_DEPENDENCY_PACKAGE_LIST=$(get_direct_dependency_package_list_of_a_package "$2")
    fi
    
    for dependencyPkgName in $DIRECT_DEPENDENCY_PACKAGE_LIST
    do
        die_if_package_is_not_available "$dependencyPkgName"

        DEPENDENCY_PACKAGE_LIST_TEMP=""

        for item in $DEPENDENCY_PACKAGE_LIST
        do
            if [ "$dependencyPkgName" = "$item" ] ; then
                continue
            else
                DEPENDENCY_PACKAGE_LIST_TEMP="$DEPENDENCY_PACKAGE_LIST_TEMP $item"
            fi
        done
        
        DEPENDENCY_PACKAGE_LIST="$dependencyPkgName $DEPENDENCY_PACKAGE_LIST_TEMP"

        __gen_dependency_list 'false' "$dependencyPkgName"
    done
}

# $1 is first call
# $2 packageName
__gen_dependency_tree() {
    unset DIRECT_DEPENDENCY_PACKAGE_LIST
    DIRECT_DEPENDENCY_PACKAGE_LIST=$(get_direct_dependency_package_list_of_a_package "$2")

    if [ "$1" = 'true' ] ; then
        unset I

        unset DEPENDENCIES__GV
        unset DEPENDENCIES_PNG
        unset DEPENDENCIES_TXT

        DEPENDENCIES__GV="$EMPTY_DIR/$2.dependencies.gv"
        DEPENDENCIES_PNG="$EMPTY_DIR/$2.dependencies.png"
        DEPENDENCIES_TXT="$EMPTY_DIR/$2.dependencies.txt"
        
        if [ -n "$DIRECT_DEPENDENCY_PACKAGE_LIST" ] ; then
            echo "digraph \"$2\" {" > "$DEPENDENCIES__GV"
        fi
    fi

    if [ -f "$DEPENDENCIES__GV" ] ; then
        print "  \"$2\" -> {" >> "$DEPENDENCIES__GV"
        for dependencyPkgName in $DIRECT_DEPENDENCY_PACKAGE_LIST
        do
            print " \"$dependencyPkgName\"" >> "$DEPENDENCIES__GV"
        done
        echo " }" >> "$DEPENDENCIES__GV"
    fi

    I=$(expr ${I-0} + 1)

    for dependencyPkgName in $DIRECT_DEPENDENCY_PACKAGE_LIST
    do
        __gen_dependency_tree 'false' "$dependencyPkgName"
    done

    I=$(expr $I - 1)

    if [ "$I" -eq 0 ] ; then
        if [ -f "$DEPENDENCIES__GV" ] ; then
            echo "}" >> "$DEPENDENCIES__GV"

            if command -v dot > /dev/null ; then
                dot -Tpng -o "$DEPENDENCIES_PNG" "$DEPENDENCIES__GV"
            else
                warn "graphviz is not installed. we do not generate png format dependency image."
            fi

            # https://github.com/ggerganov/dot-to-ascii
            curl \
                -o "$DEPENDENCIES_TXT" \
                -s \
                -G \
                --data-urlencode "boxart=1" \
                --data-urlencode "src=$(cat $DEPENDENCIES__GV)" \
                "https://dot-to-ascii.ggerganov.com/dot-to-ascii.php"
        fi
    fi
}

__get_brew_package_name_by_command_name() {
    case $1 in
       gmake) echo 'make'  ;;
       cmake) echo 'cmake' ;;
       smake) echo 'smake' ;;
       meson) echo 'meson' ;;
       ninja) echo 'ninja' ;;
       patch) echo 'patch' ;;
       gperf) echo 'gperf' ;;
        nasm) echo 'nasm'  ;;
        yasm) echo 'yasm'  ;;
        gsed) echo 'gnu-sed' ;;
        flex) echo 'flex'  ;;
       bison) echo 'bison' ;;
          go) echo 'go'    ;;
        perl) echo 'perl'  ;;
        tree) echo 'tree'  ;;
       xmlto) echo 'xmlto' ;;
     itstool) echo 'itstool' ;;
      protoc) echo 'protobuf' ;;
    help2man) echo 'help2man' ;;
     doxygen) echo 'doxygen'  ;;
      ps2pdf) echo "ghostscript" ;;
    pkg-config) echo 'pkg-config' ;;
    glibtool|glibtoolize)
              echo "libtool" ;;
    autoreconf|autoconf|automake|autoheader)
              echo "automake" ;;
    esac
}

__version() {
    case "$1" in
        cmake) "$2" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         make) "$2" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
        gmake) "$2" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
       rustup) "$2" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        cargo) "$2" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
           go) "$2" version | cut -d ' ' -f3 | cut -c3- ;;
   pkg-config) "$2" --version 2> /dev/null | head -n 1 ;;
       m4|gm4) "$2" --version 2> /dev/null | head -n 1 | awk '{print($NF)}';;
     automake|aclocal)
               "$2" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
     autoconf|autoheader|autom4te|autoreconf|autoscan|autoupdate|ifnames)
               "$2" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
      libtool) "$2" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
   libtoolize|glibtoolize)
               "$2" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
         flex) "$2" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        bison) "$2" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
         yacc) "$2" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
         nasm) "$2" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         yasm) "$2" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        patch) "$2" --version 2> /dev/null | head -n 1 | awk '{print($NF)}' ;;
        gperf) "$2" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         file) "$2" --version 2> /dev/null | head -n 1 | cut -d '-' -f2 ;;
      itstool) "$2" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        xmlto) "$2" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
      xmllint) ;;
     xsltproc) ;;
         gzip)
            unset TEMP_FILE
            TEMP_FILE=$(mktemp)
            gzip --version > $TEMP_FILE 2>&1
            cat $TEMP_FILE | head -n 1 | awk '{print($NF)}'
            rm $TEMP_FILE
            unset TEMP_FILE
            ;;
         lzip) "$2" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
           xz) "$2" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
          zip) "$2" --version 2> /dev/null | sed -n '2p' | cut -d ' ' -f4 ;;
        unzip) "$2" -v        2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        bzip2)
            unset TEMP_FILE
            TEMP_FILE=$(mktemp)
            bzip2 --help 2> $TEMP_FILE
            cat $TEMP_FILE | head -n 1 | cut -d ' ' -f8 | cut -d ',' -f1
            rm $TEMP_FILE
            unset TEMP_FILE
            ;;
          tar)
            VERSION_MSG=$("$2" --version 2> /dev/null | head -n 1)
            case $VERSION_MSG in
                  tar*) echo "$VERSION_MSG" | cut -d ' ' -f4 ;;
               bsdtar*) echo "$VERSION_MSG" | cut -d ' ' -f2 ;;
            esac
            ;;
          git) "$2" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         curl) "$2" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
     awk|gawk) "$2" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 | tr , ' ' ;;
     sed|gsed) "$2" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
          pip) "$2" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
         cpan) ;;
         grep) "$2" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 | cut -d '-' -f1 ;;
         ruby) "$2" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
         perl) "$2" -v | sed -n '2p' | sed 's/.*v\([0-9]\.[0-9][0-9]\.[0-9]\).*/\1/' ;;
    python|python2|python3)
            unset TEMP_FILE
            TEMP_FILE=$(mktemp)
            "$2" --version > $TEMP_FILE 2>&1
            cat $TEMP_FILE | head -n 1 | cut -d ' ' -f2
            rm $TEMP_FILE
            unset TEMP_FILE
            ;;
         node) "$2" --version 2> /dev/null | head -n 1 | cut -d 'v' -f2 ;;
          zsh) "$2" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
         bash) "$2" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 | cut -d '(' -f1 ;;
            *) "$2" --version 2> /dev/null | head -n 1
    esac
}

__config_glob_installation_variables() {
    if [ -z "$PKG_CONFIG" ] ; then
        PKG_CONFIG=$(command -v pkg-config) ||
        PKG_CONFIG=$(command -v pkgconfig) ||
        PKG_CONFIG=$(command -v pkgconf)
    fi

    if [ -z "$YASM" ] ; then
        if [ -f  "$TOOLCHAIN_BIN_DIR/yasm" ] ; then
            YASM="$TOOLCHAIN_BIN_DIR/yasm"
        fi
    fi

    for item in $(echo "$PATH" | tr ':' ' ')
    do
        if [ -z "$CMAKE" ] ; then
            if [ -f "$item/cmake" ] && [ -x "$item/cmake" ] ; then
                CMAKE="$item/cmake"
            fi
        fi

        if [ -z "$MESON" ] ; then
            if [ -f "$item/meson" ] && [ -x "$item/meson" ] ; then
                MESON="$item/meson"
            fi
        fi

        if [ -n "$CMAKE" ] && [ -n "$MESON" ] ; then
            break
        fi
    done

    if [   -f "$MY_HOME_DIR/tools.txt" ] ; then
        rm -f "$MY_HOME_DIR/tools.txt"
    fi

    for tool in go cargo rustup pkg-config cmake meson ninja make gmake bmake m4 gm4 autoconf automake libtool libtoolize glibtoolize flex bison yacc nasm yasm patch gperf doxygen itstool xmlto xmllint xsltproc file zip unzip xz bzip2 gzip lzip tar curl git awk gawk sed gsed grep cpan gem pip npm yarn ruby perl python python2 python3 node bash zsh
    do
        unset TOOL_PATH
        unset TOOL_UPPER
        unset TOOL_VERSION

        TOOL_UPPER=$(echo "$tool" | tr a-z A-Z | tr - _)
        TOOL_PATH="$(eval echo \$$TOOL_UPPER)"

        if [ -n "$TOOL_PATH" ] ; then
            if [ ! -f "$TOOL_PATH" ] || [ ! -x "$TOOL_PATH" ] ; then
                TOOL_PATH=''
            fi
        fi

        if [ -z "$TOOL_PATH" ] ; then
            TOOL_PATH=$(command -v "$tool")
            if [ "$tool" = "$TOOL_PATH" ] ; then
                TOOL_PATH=''
            fi
        fi

        if [ -n "$TOOL_PATH" ] ; then
            TOOL_VERSION=$(__version "$tool" "$TOOL_PATH")
        fi

        printf "%11s %-10s %s\n" "$tool" "$TOOL_VERSION" "$TOOL_PATH" | tee -a "$MY_HOME_DIR/tools.txt"

        if [ -z "$TOOL_PATH" ] ; then
            TOOL_PATH="$tool"
        fi

        eval $TOOL_UPPER=\"$TOOL_PATH\"
    done

    echo

    for tool in $(list_tools_in_the_toolchain)
    do
        unset TOOL_PATH
        case $tool in
            cc)
                if [ -z "$CC" ] ; then
                    TOOL_PATH=$(command -v cc) ||
                    TOOL_PATH=$(command -v gcc) ||
                    TOOL_PATH=$(command -v clang)
                else
                    TOOL_PATH="$CC"
                fi
                ;;
            cxx)
                if [ -z "$CXX" ] ; then
                    TOOL_PATH=$(command -v c++) ||
                    TOOL_PATH=$(command -v g++) ||
                    TOOL_PATH=$(command -v clang++)
                else
                    TOOL_PATH="$CXX"
                fi
                ;;
            *)  TOOL_PATH=$(command -v "$tool")
        esac

        unset TOOL_UPPER
        TOOL_UPPER=$(echo "$tool" | tr a-z A-Z)

        eval $TOOL_UPPER=$TOOL_PATH
        eval export ${TOOL_UPPER}_FOR_BUILD=\"$TOOL_PATH\"
    done
    unset TOOL_PATH
    unset TOOL_UPPER

    for FLAG in $(list_flags_used_by_tools_in_the_toolchain)
    do
        eval export ${FLAG}_FOR_BUILD=\"\$$FLAG\"
    done
    unset FLAG

    export PATH="$TOOLCHAIN_BIN_DIR:$PATH"

    MAKEFLAGS='-w'

    if [ "$VERBOSE" = 'true' ] ; then
        export PKG_CONFIG_DEBUG_SPEW=set
        MAKEFLAGS="$MAKEFLAGS --debug"
    fi
}

____install_packages() {
    check_prerequisites

    parse_arguments "$@"

    die_if_package_list_is_not_specified "$USER_SPECIFIED_PACKAGE_LIST"

    __config_glob_installation_variables

    __gen_dependency_list 'true' '' || return 1

    echo "$COLOR_PURPLE==>$COLOR_OFF to install$COLOR_GREEN $DEPENDENCY_PACKAGE_LIST $COLOR_OFF\n"

    for INSTALLING_PACKAGE in $DEPENDENCY_PACKAGE_LIST
    do
        if is_package_installed "$INSTALLING_PACKAGE" ; then
            printf "$COLOR_GREEN%-10s$COLOR_OFF already have been installed.\n" "$INSTALLING_PACKAGE"
        else
            printf "$COLOR_PURPLE==>$COLOR_OFF installing $COLOR_GREEN%s$COLOR_OFF\n\n" "$INSTALLING_PACKAGE"
            __install_a_package "$INSTALLING_PACKAGE"
        fi
    done
}

die_if_command_not_found() {
    case $1 in
       cmake) [ "$CMAKE" = "cmake" ] && die_from_command_not_found "$1" "CMAKE" ;;
       meson) [ "$MESON" = "meson" ] && die_from_command_not_found "$1" "MESON" ;;
       pkg-config|pkgconfig|pkgconf)
              [ "$PKG_CONFIG" = 'pkg-config' ] && die_from_command_not_found "$1" "PKG_CONFIG" ;;
           *) command -v "$1" > /dev/null || die_from_command_not_found "$1"
    esac
}

die_from_command_not_found() {
    if [ -z "$2" ] ; then
        die "command not found: $1. please make sure it in PATH."
    else
        die "command not found: $1. please make sure it in PATH or export $2=path/to/$1 environment."
    fi
}

die_from_installation_failed() {
    if [ -z "$BUILD_FOR_ABI" ] ; then
        die "install $1 failed! you can go to $WORKING_DIR to see see."
    else
        die "install $1/$BUILD_FOR_ABI failed! you can go to $WORKING_DIR to see see."
    fi
}

__install_a_package() {
    unset BUILD_FOR_ABI

    __fetch_resources_of_a_package "$1"

    for bin in $PACKAGE_REQUIRE
    do
        case $bin in
            go)    PACKAGE_REQUIRE_GO=true ;;
            cargo) PACKAGE_REQUIRE_CARGO=true ;;
        esac
        die_if_command_not_found "$bin"
    done

    if WORKING_DIR=$(mktemp -d) ; then
        echo "$COLOR_PURPLE==>$COLOR_OFF ${COLOR_GREEN}mkdir $WORKING_DIR${COLOR_OFF}\n"
    else
        die "create working directory failed."
    fi

    case $PACKAGE_SRC_URL in
        dir://*|*.git)
            run cp -r "$PACKAGE_SRC_PATH/*" "$WORKING_DIR" || return 1
            ;;
        *.c|*.cc|*.cxx|*.cpp)
            run cp    "$PACKAGE_SRC_PATH"   "$WORKING_DIR" || return 1
            ;;
        *.zip)
            run unzip "$PACKAGE_SRC_PATH" -d "$WORKING_DIR" || return 1
            ;;
        *.tar.xz|*.tar.gz|*.tar.lz|*.tar.bz2|*.tgz|*.txz)
            run tar xf "$PACKAGE_SRC_PATH" -C "$WORKING_DIR" --strip-components 1 || return 1
            ;;
        *)  die "$PACKAGE_SRC_URL : extension isn't recognized. the supported extensions are .zip .tar.xz .tar.gz .tar.lz .tar.bz2 .tgz .txz"
    esac

    if [ -z "$PACKAGE_SOURCE_DIR" ] ; then
        SOURCE_DIR="$WORKING_DIR"
    else
        SOURCE_DIR="$WORKING_DIR/$PACKAGE_SOURCE_DIR"
    fi

    run cd "$SOURCE_DIR" || die "check the $FORMULA_FILE_PATH. argument of sourced command is not right."

    run ls -l

    EMPTY_DIR="$WORKING_DIR/$TIMESTAMP_UNIX"
    BUILD_DIR="$EMPTY_DIR/native"

    run install -d "$BUILD_DIR" || return 1

    if command -v prepare > /dev/null ; then
        # may be build something for building
        
        echo

        printf "%17s = %s\n\n" "PACKAGE_NAME" "$PACKAGE_NAME"

        for TOOL in $(list_tools_in_the_toolchain | tr a-z A-Z)
        do
            eval export $TOOL=\$"${TOOL}_FOR_BUILD"
            printf "%17s = %s\n" "$TOOL" "$(eval echo \$$TOOL)"
        done

        for FLAG in $(list_flags_used_by_tools_in_the_toolchain)
        do
            eval export $FLAG=\$"${FLAG}_FOR_BUILD"
            printf "\n%17s = " "$FLAG"
            FIRST='true'
            for item in $(eval echo \$$FLAG | tr ':' ' ')
            do
                if [ "$FIRST" = 'true' ] ; then
                    FIRST='false'
                    echo "$item"
                else
                    echo "                   $item"
                fi
            done
        done

        echo
        echo
        echo "      WORKING_DIR = $WORKING_DIR"
        echo "       SOURCE_DIR = $SOURCE_DIR"
        echo "        EMPTY_DIR = $EMPTY_DIR"
        echo "        BUILD_DIR = $BUILD_DIR"
        echo "              PWD = $PWD"
        echo

        run prepare || die_from_installation_failed "$1"
    fi

    __install_a_package_all_builds "$1" || die_from_installation_failed "$1"

    echo
    success "$1 have been installed successfully.\n"

    if [ "$KEEP_WORKING_DIR" != 'true' ] ; then
        run rm -rf "$WORKING_DIR" || true
    fi

    echo
    __tree_installed_of_a_package "$1" || true
}

__install_a_package_all_builds() {
    unset BUILD_ROUND_NUM

    __gen_dependency_list 'true' "$1" || return 1

    __gen_dependency_tree 'true' "$1" || return 1

    PKG_INSTALL_DIR="$MY_INSTALL_DIR/$1"

    unset BUILD_FOR_ABI_LIST

    for BUILD in $BUILD_LIST
    do
        BUILD_ROUND_NUM=$(expr ${BUILD_ROUND_NUM-0} + 1)

        BUILD_FOR_ABI=$(echo "$BUILD" | cut -d: -f1)

        if [ -z "$BUILD_FOR_ABI_LIST" ] ; then
            BUILD_FOR_ABI_LIST="$BUILD_FOR_ABI"
        else
            BUILD_FOR_ABI_LIST=$(printf "%s\n%s" "$BUILD_FOR_ABI_LIST" "$BUILD_FOR_ABI")
        fi

        BUILD_DIR="$EMPTY_DIR/$BUILD_FOR_ABI"
        run mkdir -p "$BUILD_DIR" || return 1

        if [ "$DRYRUN" = 'true' ] ; then
            ___dryrun_a_package_one_build "$1" || return 1
        else
            (
                cd "$BUILD_DIR" &&
                mkfifo pipe &&
                (tee install.log.txt < pipe &) &&
                __install_a_package_one_build "$1" > pipe 2>&1
            ) || return 1
        fi
    done

    echo "$BUILD_FOR_ABI_LIST" > "$PKG_INSTALL_DIR/manifest.txt"
}

___dryrun_a_package_one_build() {
    if [ -z "$SHELL" ] ; then
        SHELL=$(command -v zsh) ||
        SHELL=$(command -v bash) ||
        SHELL=$(command -v sh)
    fi
    __config_this_build_variables "$1" &&
    __printf_this_build_variables "$1" &&
    exec "$SHELL"
}

__install_a_package_one_build() {
    if [ "$PACKAGE_BUILD_IN_SOURCE_DIR" = 'true' ] ; then
        run cd "$SOURCE_DIR" || return 1
    fi

    run __config_this_build_variables "$1" &&
    run __printf_this_build_variables "$1" &&
    run rm -rf "$ABI_INSTALL_DIR" &&
    run build && {
        [ -d "$ABI_INSTALL_DIR" ] || {
            error "installed nothing."
            return 1
        }
    } &&
    run __justfy_pc_files &&
    run __install_logs "$1"
}

__justfy_pc_files() {
    if [ -d "$ABI_PKGCONF_DIR" ] ; then
        for item in $(find "$ABI_PKGCONF_DIR" -name "*.pc")
        do
            sed_in_place 's/-lpthread//g' "$item" || return 1
            if grep 'Libs.private:' "$item" > /dev/null ; then
                LIBS_CONTENT=$(awk '/Libs:/{print}' "$item" || return 1)
                LIBS_PRIVATE_CONTENT=$(awk -F: '/Libs.private:/{print $2}' "$item" || return 1)
                sed_in_place "s|$LIBS_CONTENT|$LIBS_CONTENT$LIBS_PRIVATE_CONTENT|" "$item" || return 1
                sed_in_place '/Libs.private/d' "$item" || return 1
            fi
        done
    fi
}

__install_logs() {
    ABI_LOG_DIR="$ABI_INSTALL_DIR/log"

    run install -d "$ABI_LOG_DIR" || return 1

    install_installed_log

    for item in "$MY_FORMULA_DIR/$1.sh" "$MY_HOME_DIR/tools.txt" "$BUILD_DIR/install.log.txt" "$DEPENDENCIES__GV" "$DEPENDENCIES_PNG" "$DEPENDENCIES_TXT"
    do
        if [ -f "$item" ] ; then
            run install -m 644 "$item" "$ABI_LOG_DIR" || return 1
        fi
    done

    for item in "$BUILD_DIR" "$SOURCE_DIR"
    do
        for item2 in 'config.log' 'compile_commands.json'
        do
            if [ -f "$item/$item2" ] ; then
                run install -m 644 "$item/$item2" "$ABI_LOG_DIR" || return 1
            fi
        done
    done
}

install_incs() {
    while [ -n "$1" ]
    do
        unset X1
        unset X2
        X1=$(echo "$1" | cut -d: -f1)
        X2=$(echo "$1" | cut -d: -f2)

        [ "$X1" = "$X2" ] && unset X2

        run install -d         "$ABI_INCLUDE_DIR/$X2" || return 1
        run install -m 644 $X1 "$ABI_INCLUDE_DIR/$X2" || return 1

        shift
    done
}

install_libs() {
    install -v -d "$ABI_LIBRARY_DIR" || return 1
    for item in $@
    do
        case $item in
            *.a) install -v -m 644 $item "$ABI_LIBRARY_DIR" || return 1 ;;
            *)   install -v -m 755 $item "$ABI_LIBRARY_DIR" || return 1 ;;
        esac
    done
}

install_pcfs() {
    install -v -d        "$ABI_PKGCONF_DIR" &&
    install -v -m 644 $@ "$ABI_PKGCONF_DIR"
}

install_bins() {
    install -v -d        "$ABI_BINARY__DIR" &&
    install -v -m 755 $@ "$ABI_BINARY__DIR"
}

install_mans() {
    for item in $@
    do
        unset NUMBER
        NUMBER=$(echo "$item" | cut -c ${#item}-${#item})
        case $NUMBER in
            [1-8]);;
            *)    die "$item: not a manpage."
        esac
        install -v -d           "$ABI_INSTALL_DIR/share/man/man$NUMBER" &&
        install -v -m 644 $item "$ABI_INSTALL_DIR/share/man/man$NUMBER"
    done
}

install_pc_file() {
    install -v -d "$ABI_PKGCONF_DIR" &&
    cat >         "$ABI_PKGCONF_DIR/$1.pc"
}

install_files() {
    while [ -n "$1" ]
    do
        case $(echo "$1" | cut -d: -f1) in
            *.[1-8]) install_mans "$1" || return 1 ;;
            *.h)     install_incs "$1" || return 1 ;;
            *.a)     install_libs "$1" || return 1 ;;
            *.so)    install_libs "$1" || return 1 ;;
            *.pc)    install_pcfs "$1" || return 1 ;;
            *)       install_bins "$1" || return 1 ;;
        esac
        shift
    done
}

__show_infomation_of_packages() {
    unset PACKAGE_LIST

    if [ -z "$1" ] ; then
        [ -d "$MY_FORMULA_DIR" ] || __update_formula_repository
        cd "$MY_FORMULA_DIR" || exit 1
        PACKAGE_LIST=$(ls *.sh | sed 's/\.sh//g')
    else
        PACKAGE_LIST=$@
    fi

    unset FIRST
    unset PACKAGE

    for PACKAGE in $PACKAGE_LIST
    do
        if [ "${FIRST-true}" = 'true' ] ; then
            FIRST=false
        else
            echo "============================================================"
        fi
        __show_infomation_of_a_package "$PACKAGE"
    done
}

__show_infomation_of_a_package() {
    ___load_formula_of_a_package "$1"

    echo "name    : $(mark_is_package_installed_or_not $1)"

    if [ -n "$PACKAGE_VERSION" ] ; then
        echo "version : $PACKAGE_VERSION"
    fi

    echo "summary : $PACKAGE_SUMMARY"
    echo "webpage : $PACKAGE_WEBPAGE"

    [ -z "$PACKAGE_DEPENDS" ] || {
        unset DEPENDENCIES

        for dependencyPkgName in $PACKAGE_DEPENDS
        do
            if [ -z "$DEPENDENCIES" ] ; then
                DEPENDENCIES="depends : $(mark_is_package_installed_or_not $dependencyPkgName)"
            else
                DEPENDENCIES="$DEPENDENCIES | $(mark_is_package_installed_or_not $dependencyPkgName)"
            fi
        done

        echo "$DEPENDENCIES"
    }

    echo "src_url : $PACKAGE_SRC_URL"

    case $PACKAGE_SRC_TYPE in
        dir) ;;
        git)
            if [ -d "$PACKAGE_SRC_PATH" ] ; then
                echo "src_cache ${COLOR_PURPLE}==>${COLOR_OFF} $PACKAGE_SRC_PATH"
            else
                echo "src_cache : ${COLOR_RED}Not cached${COLOR_OFF}"
            fi
            ;;
        *)
            if [ -f "$PACKAGE_SRC_PATH" ] ; then
                echo "src_cache ${COLOR_PURPLE}==>${COLOR_OFF} $PACKAGE_SRC_PATH"
            else
                echo "src_cache : ${COLOR_RED}Not cached${COLOR_OFF}"
            fi
    esac

    if is_package_installed "$1" ; then
        echo "installed ${COLOR_PURPLE}==>${COLOR_OFF} $(du -sh "$MY_INSTALL_DIR/$1" | awk '{print $2, $1}')"

        unset I
        unset ABI
        unset ABI_LIST
        unset ABI_LIST_LENGTH

        ABI_LIST=$(cat "$MY_INSTALL_DIR/$1/manifest.txt")
        ABI_LIST_LENGTH=$(list_length $ABI_LIST)

        for ABI in $ABI_LIST
        do
            I=$(expr ${I-0} + 1)
            if [ "$I" -eq "$ABI_LIST_LENGTH" ] ; then
                echo "              â””â”€â”€ $(printf "%-12s" "$ABI") $(du -sh "$MY_INSTALL_DIR/$1/$ABI" | awk '{print $1}')"
            else
                echo "              â”œâ”€â”€ $(printf "%-12s" "$ABI") $(du -sh "$MY_INSTALL_DIR/$1/$ABI" | awk '{print $1}')"
            fi
        done

        die_if_load_installed_log_failed "$1" "$ABI"
        __show_installed_log "$1" "$ABI"
    fi
}

mark_is_package_installed_or_not() {
    if is_package_installed "$1" ; then
        echo "${COLOR_GREEN}$1${COLOR_OFF}"
    else
        echo "${COLOR_RED}$1${COLOR_OFF}"
    fi
}

summary() {
    if [ $# -eq 0 ] ; then
        echo "$PACKAGE_SUMMARY"
    else
        PACKAGE_SUMMARY="$1"
    fi
}

webpage() {
    if [ $# -eq 0 ] ; then
        echo "$PACKAGE_WEBPAGE"
    else
        PACKAGE_WEBPAGE="$1"
    fi
}

src_git() {
    if [ $# -eq 0 ] ; then
        echo "$PACKAGE_SRC_GIT"
    else
        PACKAGE_SRC_GIT="$1"
    fi
}

src_url() {
    if [ $# -eq 0 ] ; then
        echo "$PACKAGE_SRC_URL"
    else
        PACKAGE_SRC_URL="$1"
    fi
}

src_sum() {
    if [ $# -eq 0 ] ; then
        echo "$PACKAGE_SRC_SUM"
    else
        PACKAGE_SRC_SUM="$1"
    fi
}

sourced() {
    if [ $# -eq 0 ] ; then
        echo "$PACKAGE_SOURCE_DIR"
    else
        PACKAGE_SOURCE_DIR="$1"
    fi
}

build_in_sourced() {
    PACKAGE_BUILD_IN_SOURCE_DIR=true
}

version() {
    if [ $# -eq 0 ] ; then
        echo "$PACKAGE_VERSION"
    else
        PACKAGE_VERSION="$1"
    fi
}

license() {
    if [ $# -eq 0 ] ; then
        echo "$PACKAGE_LICENSE"
    else
        if [ -z "$PACKAGE_LICENSE" ] ; then
            PACKAGE_LICENSE="$@"
        else
            PACKAGE_LICENSE="$PACKAGE_LICENSE $@"
        fi
    fi
}

require() {
    if [ $# -eq 0 ] ; then
        echo "$PACKAGE_REQUIRE"
    else
        if [ -z "$PACKAGE_REQUIRE" ] ; then
            PACKAGE_REQUIRE="$@"
        else
            PACKAGE_REQUIRE="$PACKAGE_REQUIRE $@"
        fi
    fi
}

depends() {
    if [ $# -eq 0 ] ; then
        echo "$PACKAGE_DEPENDS"
    else
        if [ -z "$PACKAGE_DEPENDS" ] ; then
            PACKAGE_DEPENDS="$@"
        else
            PACKAGE_DEPENDS="$PACKAGE_DEPENDS $@"
        fi
    fi
}

# -Dkey=value
cdefine() {
    if [ $# -eq 0 ] ; then
        echo "$PACKAGE_CDEFINE"
    else
        if [ -z "$PACKAGE_CDEFINE" ] ; then
            PACKAGE_CDEFINE="$@"
        else
            PACKAGE_CDEFINE="$PACKAGE_CDEFINE $@"
        fi
    fi
}

ldflags() {
    if [ $# -eq 0 ] ; then
        echo "$PACKAGE_LDFLAGS"
    else
        if [ -z "$PACKAGE_LDFLAGS" ] ; then
            PACKAGE_LDFLAGS="$@"
        else
            PACKAGE_LDFLAGS="$PACKAGE_LDFLAGS $@"
        fi
    fi
}

patches() {
    if [ $# -eq 0 ] ; then
        echo "$PACKAGE_PATCHES"
    else
        [ $# -lt 2 ]             && die "the number of arguments of patches command at least 2."
        [ $(expr $# % 2) -eq 1 ] && die "the number of arguments of patches command must be even integer."

        PACKAGE_PATCHES="$@"

        while [ -n "$1" ]
        do
            case $1 in
                *.patch)   PATCH_CONTENT_TYPE=patch  ;;
                *.zip)     PATCH_CONTENT_TYPE=zip    ;;
                *.tar.xz)  PATCH_CONTENT_TYPE=tar.xz ;;
                *.tar.gz)  PATCH_CONTENT_TYPE=tar.gz ;;
                *.tar.lz)  PATCH_CONTENT_TYPE=tar.lz ;;
                *.tar.bz2) PATCH_CONTENT_TYPE=tar.bz2;;
                *.tgz)     PATCH_CONTENT_TYPE=tar.gz ;;
                *.txz)     PATCH_CONTENT_TYPE=tar.xz ;;
                *)  die "$1 : extension isn't recognized. the supported extensions are .patch .zip .tar.xz .tar.gz .tar.lz .tar.bz2 .tgz .txz"
            esac

            [ ${#2} -eq 64 ] || die "$2 is not sha256sum. the length of sha256sum must be 64."

            shift 2
        done
    fi
}

sdk_api() {
    if [ $# -eq 0 ] ; then
        echo "$MIN_SDK_API_LEVEL"
    else
        PACKAGE_MIN_SDK_API_LEVEL="$1"
    fi
}

___load_formula_of_a_package() {
    die_if_package_is_not_available "$1"

    unset PACKAGE_NAME
    unset PACKAGE_SUMMARY
    unset PACKAGE_WEBPAGE
    unset PACKAGE_SRC_GIT
    unset PACKAGE_SRC_URL
    unset PACKAGE_SRC_SUM
    unset PACKAGE_SRC_NAME
    unset PACKAGE_SRC_PATH
    unset PACKAGE_SRC_TYPE
    unset PACKAGE_VERSION
    unset PACKAGE_LICENSE
    unset PACKAGE_PATCHES

    unset PACKAGE_REQUIRE
    unset PACKAGE_REQUIRE_GO
    unset PACKAGE_REQUIRE_CARGO

    unset PACKAGE_DEPENDS

    unset PACKAGE_CDEFINE
    unset PACKAGE_LDFLAGS

    unset MIN_SDK_API_LEVEL
    unset PACKAGE_MIN_SDK_API_LEVEL

    # relative to $WORKING_DIR, which contains configure, CMakeLists.txt, etc.
    unset PACKAGE_SOURCE_DIR
    unset PACKAGE_BUILD_IN_SOURCE_DIR

    unset -f prepare
    unset -f build
    unset -f build_configed

    PACKAGE_NAME="$1"

    FORMULA_FILE_PATH="$MY_FORMULA_DIR/$PACKAGE_NAME.sh"

    . "$FORMULA_FILE_PATH" || die "$FORMULA_FILE_PATH is broken."

    [ -z "$PACKAGE_SUMMARY" ] && die "summary command must be invoked in $FORMULA_FILE_PATH"
    [ -z "$PACKAGE_WEBPAGE" ] && die "webpage command must be invoked in $FORMULA_FILE_PATH"
    [ -z "$PACKAGE_SRC_URL" ] && die "src_url command must be invoked in $FORMULA_FILE_PATH"

    if [ -z "$PACKAGE_MIN_SDK_API_LEVEL" ] ; then
        PACKAGE_MIN_SDK_API_LEVEL=$(__list_supported_sdk_api_levels | head -n 1)
    fi

    if [ -z "$USER_SPECIFIED_MIN_SDK_API_LEVEL" ] ; then
        MIN_SDK_API_LEVEL=$PACKAGE_MIN_SDK_API_LEVEL
    else
        if [ "$PACKAGE_MIN_SDK_API_LEVEL" -gt "$USER_SPECIFIED_MIN_SDK_API_LEVEL" ] ; then
            die "$PACKAGE_NAME supportted min-sdk-api-level is $PACKAGE_MIN_SDK_API_LEVEL, but you want is $USER_SPECIFIED_MIN_SDK_API_LEVEL"
        else
            MIN_SDK_API_LEVEL=$USER_SPECIFIED_MIN_SDK_API_LEVEL
        fi
    fi

    case $PACKAGE_SRC_URL in
        dir://*)   PACKAGE_SRC_TYPE=dir ;;
        *.git)     PACKAGE_SRC_TYPE=git ;;
        *.zip)     PACKAGE_SRC_TYPE=zip ;;
        *.tar.xz)  PACKAGE_SRC_TYPE=tar.xz ;;
        *.tar.gz)  PACKAGE_SRC_TYPE=tar.gz ;;
        *.tar.lz)  PACKAGE_SRC_TYPE=tar.lz ;;
        *.tar.bz2) PACKAGE_SRC_TYPE=tar.bz2;;
        *.tgz)     PACKAGE_SRC_TYPE=tar.gz ;;
        *.txz)     PACKAGE_SRC_TYPE=tar.xz ;;
        *.c)       PACKAGE_SRC_TYPE=c   ;;
        *.cc)      PACKAGE_SRC_TYPE=cxx ;;
        *.cxx)     PACKAGE_SRC_TYPE=cxx ;;
        *.cpp)     PACKAGE_SRC_TYPE=cxx ;;
        *)  die "$PACKAGE_SRC_URL : extension isn't recognized. the supported extensions are .git .zip .tar.xz .tar.gz .tar.lz .tar.bz2 .tgz .txz"
    esac

    case $PACKAGE_SRC_TYPE in
        dir)
            if command -v cut > /dev/null ; then
                PACKAGE_SRC_PATH=$(echo $PACKAGE_SRC_URL | cut -c7-${#PACKAGE_SRC_URL})
            elif command -v awk > /dev/null ; then
                PACKAGE_SRC_PATH=$(echo $PACKAGE_SRC_URL | awk '{print(substr($0, 7))}')
            else
                PACKAGE_SRC_PATH=$(expr substr "$PACKAGE_SRC_URL" 7 ${#PACKAGE_SRC_URL})
            fi
            [ -d "$PACKAGE_SRC_PATH" ] || "src_url argument point to dir is not exist."
            ;;
        git)
            PACKAGE_SRC_NAME="$PACKAGE_NAME.git"
            PACKAGE_SRC_PATH="$MY_CACHED_DIR/$PACKAGE_SRC_NAME"
            ;;
        *)
            if [ -z "$PACKAGE_SRC_SUM" ] ; then
                die "src_sum command is not invoked in $FORMULA_FILE_PATH"
            fi
            if [ -z "$PACKAGE_VERSION" ] ; then
                PACKAGE_VERSION="$(basename "$PACKAGE_SRC_URL" | awk '{str = tolower($0); gsub(".tar.xz", "", str); gsub(".tar.gz", "", str); gsub(".tar.lz", "", str); gsub(".tar.bz2", "", str); gsub(".tgz", "", str); gsub(".txz", "", str); gsub(".zip", "", str); print(str)}' | awk -F- '{print $NF}')"
                if [ -z "$PACKAGE_VERSION" ] ; then
                    die "version command is not invoked in $FORMULA_FILE_PATH"
                else
                    case $PACKAGE_VERSION in
                        v*) if command -v cut > /dev/null ; then
                                PACKAGE_VERSION=$(echo $PACKAGE_VERSION | cut -c2-${#PACKAGE_VERSION})
                            elif command -v awk > /dev/null ; then
                                PACKAGE_VERSION=$(echo $PACKAGE_VERSION | awk '{print(substr($0, 2))}')
                            else
                                PACKAGE_VERSION=$(expr substr "$PACKAGE_VERSION" 2 ${#PACKAGE_VERSION})
                            fi
                    esac
                fi
            fi
            PACKAGE_SRC_NAME="$PACKAGE_NAME-$PACKAGE_VERSION.$PACKAGE_SRC_TYPE"
            PACKAGE_SRC_PATH="$MY_CACHED_DIR/$PACKAGE_SRC_NAME"
    esac
}

install_installed_log() {
    cat > "$ABI_LOG_DIR/installed.log.txt" <<EOF
installed_datetime=$TIMESTAMP_UNIX
installed_version=$PACKAGE_VERSION
min_sdk_api_level=$MIN_SDK_API_LEVEL
using_ndk_version=$ANDROID_NDK_VERSION
EOF
}

die_if_load_installed_log_failed() {
    die_if_package_is_not_installed "$1"
    die_if_abi_____is_not_supported "$2"

    INSTALLED_LOG_FILE_PATH="$MY_INSTALL_DIR/$1/$2/log/installed.log.txt"

    unset installed_datetime
    unset installed_version
    unset min_sdk_api_level
    unset using_ndk_version
    
    . "$INSTALLED_LOG_FILE_PATH" || die "$INSTALLED_LOG_FILE_PATH is broken."
}

__show_installed_log() {
    echo "installed_datetime: $(format_unix_timestamp $installed_datetime '+%Y/%m/%d %H:%M:%S')"
    echo "installed_version : $installed_version"
    echo "min_sdk_api_level : $min_sdk_api_level"
    echo "using_ndk_version : $using_ndk_version"
}

__config_this_build_variables() {
    die_if_package_is_not_available "$1"

    BUILD_FOR_ARCH=$(echo_arch_by_abi "$BUILD_FOR_ABI")
    BUILD_FOR_TARGET=$(echo_target_by_arch "$BUILD_FOR_ARCH")

    for tool in $(list_tools_in_the_toolchain)
    do
        if [ "$tool" = 'cpp' ] ; then
            CPP="$CC -E"
        else
            eval $(echo "$tool" | tr a-z A-Z)=$(echo_path_of_tool_in_the_toolchain "$tool")
        fi
    done

    SYSTEM_INCLUDE_DIR="$SYSROOT/usr/include"
    SYSTEM_LIBRARY_DIR="$SYSROOT/usr/lib/$(echo $BUILD_FOR_TARGET | sed 's/armv7a/arm/')/$MIN_SDK_API_LEVEL"

      CFLAGS="--sysroot $SYSROOT -Qunused-arguments -Os -fpic"
    CPPFLAGS="--sysroot $SYSROOT -Qunused-arguments"
     LDFLAGS="--sysroot $SYSROOT"

    for item in $PACKAGE_CDEFINE
    do
        CPPFLAGS="$CPPFLAGS -D$item"
    done

    if [ -n "$PACKAGE_LDFLAGS" ] ; then
        LDFLAGS="$LDFLAGS $PACKAGE_LDFLAGS"
    fi

    # https://stackoverflow.com/questions/32826175/ftello-and-fseeko-android-build-errors
    # int fseeko(FILE* __fp, off_t __offset, int __whence) __RENAME(fseeko64) __INTRODUCED_IN(24);
    # off_t ftello(FILE* __fp) __RENAME(ftello64) __INTRODUCED_IN(24);
    if [ $MIN_SDK_API_LEVEL -lt 24 ] ; then
        CPPFLAGS="$CPPFLAGS -Dftello=ftell -Dfseeko=fseek"
    fi

    # https://www.freedesktop.org/wiki/Software/pkg-config/CrossCompileProposal
    unset PKG_CONFIG_LIBDIR
    unset PKG_CONFIG_PATH

    for PACKAGE in $DEPENDENCY_PACKAGE_LIST
    do
        PKG=$(printf "$PACKAGE" | tr '-' '_')
        
        ABI_INSTALL_DIR="$MY_INSTALL_DIR/$PACKAGE/$BUILD_FOR_ABI"
        ABI_INCLUDE_DIR="$ABI_INSTALL_DIR/include"
        ABI_LIBRARY_DIR="$ABI_INSTALL_DIR/lib"
        ABI_PKGCONF_DIR="$ABI_INSTALL_DIR/lib/pkgconfig"

        eval "${PKG}_INSTALL_DIR='$ABI_INSTALL_DIR'"
        eval "${PKG}_INCLUDE_DIR='$ABI_INCLUDE_DIR'"
        eval "${PKG}_LIBRARY_DIR='$ABI_LIBRARY_DIR'"

        CPPFLAGS="-I$ABI_INCLUDE_DIR $CPPFLAGS"
         LDFLAGS="-L$ABI_LIBRARY_DIR $LDFLAGS"
        PKG_CONFIG_PATH="$PKG_CONFIG_PATH:$ABI_PKGCONF_DIR"
    done

    if [ "$VERBOSE" = 'true' ] ; then
        CFLAGS="$CFLAGS -v"
    fi

    CXXFLAGS="$CFLAGS"

    ABI_INSTALL_DIR="$PKG_INSTALL_DIR/$BUILD_FOR_ABI"
    ABI_BINARY__DIR="$ABI_INSTALL_DIR/bin"
    ABI_INCLUDE_DIR="$ABI_INSTALL_DIR/include"
    ABI_LIBRARY_DIR="$ABI_INSTALL_DIR/lib"
    ABI_PKGCONF_DIR="$ABI_INSTALL_DIR/lib/pkgconfig"

    if [ "$PACKAGE_REQUIRE_CARGO" = 'true' ] ; then
        for supportedTarget in $(__list_supported_targets)
        do
            supportedTarget=$(echo "$supportedTarget" | sed 's/armv7a/armv7/')
            for installedTarget in $(rustup target list | grep installed | cut -d " " -f1)
            do
                [ "$supportedTarget" = "$installedTarget" ] && break
            done
            [ "$supportedTarget" = "$installedTarget" ] || {
                rustup target add "$supportedTarget" || return 1
            }
        done

        CARGO_TARGET=$(echo "$BUILD_FOR_TARGET" | sed 's/armv7a/armv7/')

        # https://doc.rust-lang.org/cargo/reference/environment-variables.html
        CARGO_TARGET_XXX=$(echo "$CARGO_TARGET" | tr a-z A-Z | tr - _)

        eval export CARGO_TARGET_${CARGO_TARGET_XXX}_AR=$AR
        eval export CARGO_TARGET_${CARGO_TARGET_XXX}_LINKER=$CC
    fi

    if [ "$PACKAGE_REQUIRE_GO" = 'true' ] ; then
        # https://golang.org/doc/install/source#environment
        export CGO_ENABLED=1
        export CGO_CFLAGS="$CFLAGS"
        export CGO_CXXFLAGS="$CXXFLAGS"
        export CGO_CPPFLAGS="$CPPFLAGS"
        export CGO_LDFLAGS="$LDFLAGS"

        export GO111MODULE="auto"
        export GOPROXY=https://goproxy.cn

        export GOOS=android

        case $BUILD_FOR_ARCH in
            armv7a)  export GOARCH=arm   ;;
            aarch64) export GOARCH=arm64 ;;
            i686)    export GOARCH=386   ;;
            x86_64)  export GOARCH=amd64 ;;
        esac
    fi
}

__printf_this_build_variables() {
    if [ -f "$DEPENDENCIES_TXT" ] ; then
        cat "$DEPENDENCIES_TXT"
    fi

    echo "INSTALLING_PACKAGE= $1"
    echo
    echo "   TIMESTAMP_UNIX = $TIMESTAMP_UNIX"
    echo
    echo " BUILD_ROUND_NUM  = $BUILD_ROUND_NUM"
    echo
    echo " BUILD_MACHINE_OS = $BUILD_MACHINE_OS_TYPE-$BUILD_MACHINE_OS_ARCH"
    echo
    echo " BUILD_FOR_TARGET = $BUILD_FOR_TARGET"
    echo " BUILD_FOR_ARCH   = $BUILD_FOR_ARCH"
    echo " BUILD_FOR_ABI    = $BUILD_FOR_ABI"
    echo
    echo "MIN_SDK_API_LEVEL = $MIN_SDK_API_LEVEL"
    echo
    echo " ANDROID_NDK_VER  = $ANDROID_NDK_VERSION"
    echo " ANDROID_NDK_HOME = $ANDROID_NDK_HOME"
    echo
    echo "          SYSROOT = $SYSROOT"
    echo "SYSTEM_INCLUDE_DIR= $SYSTEM_INCLUDE_DIR"
    echo "SYSTEM_LIBRARY_DIR= $SYSTEM_LIBRARY_DIR"
    echo
    echo "TOOLCHAIN_BIN_DIR = $TOOLCHAIN_BIN_DIR"

    for TOOL in $(list_tools_in_the_toolchain | tr a-z A-Z)
    do
        eval export $TOOL=\"\$$TOOL\"
        printf "%17s = %s\n" "$TOOL" "$(eval echo \$$TOOL)"
    done

    echo

    for TOOL in $(list_tools_in_the_toolchain | tr a-z A-Z)
    do
        eval export ${TOOL}_FOR_BUILD="\$${TOOL}_FOR_BUILD"
        printf "%17s = %s\n" "${TOOL}_FOR_BUILD" "$(eval echo \$${TOOL}_FOR_BUILD)"
    done

    echo

    for FLAG in $(list_flags_used_by_tools_in_the_toolchain)
    do
        eval export $FLAG=\"\$$FLAG\"
        printf "\n%17s = " "$FLAG"
        FIRST=true
        for item in $(eval echo \$$FLAG | tr ':' ' ')
        do
            if [ "$FIRST" = 'true' ] ; then
                FIRST=false
                echo "$item"
            else
                echo "                    $item"
            fi
        done
    done

    echo

    if [ "$PACKAGE_REQUIRE_CARGO" = 'true' ] ; then
        echo
        env | grep CARGO
        echo
    fi

    if [ "$PACKAGE_REQUIRE_GO" = 'true' ] ; then
        echo
        echo "      GO111MODULE = $GO111MODULE"
        echo "      GOPROXY     = $GOPROXY"
        echo
        echo "     CGO_ENABLED  = $CGO_ENABLED"
        echo "     CGO_CFLAGS   = $CGO_CFLAGS"
        echo "     CGO_CXXFLAGS = $CGO_CXXFLAGS"
        echo "     CGO_CPPFLAGS = $CGO_CPPFLAGS"
        echo "     CGO_LDFLAGS  = $CGO_LDFLAGS"
        echo
        echo "           GOOS   = $GOOS"
        echo "           GOARCH = $GOARCH"
    fi

    echo
    echo "      WORKING_DIR = $WORKING_DIR"
    echo "       SOURCE_DIR = $SOURCE_DIR"
    echo "        EMPTY_DIR = $EMPTY_DIR"
    echo "        BUILD_DIR = $BUILD_DIR"
    echo "              PWD = $PWD"
    echo
    echo "  PKG_INSTALL_DIR = $PKG_INSTALL_DIR"
    echo "  ABI_INSTALL_DIR = $ABI_INSTALL_DIR"
    echo "  ABI_BINARY__DIR = $ABI_BINARY__DIR"
    echo "  ABI_INCLUDE_DIR = $ABI_INCLUDE_DIR"
    echo "  ABI_LIBRARY_DIR = $ABI_LIBRARY_DIR"
    echo "  ABI_PKGCONF_DIR = $ABI_PKGCONF_DIR"
    echo

    if [ "$VERBOSE" = 'true' ] ; then
        echo
        run export -p
        echo
    fi
}

config_url() {
    echo "http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=$1;hb=HEAD"
}

# run in a subshell
configure() {
    die_if_command_not_found make

    if [ "$BUILD_ROUND_NUM" -eq 1 ] ; then
        # https://www.gnu.org/software/gettext/manual/html_node/config_002eguess.html
        # https://git.savannah.gnu.org/cgit/config.git/tree/
        for item in config.sub config.guess
        do
            for file in $(find "$SOURCE_DIR" -name "$item")
            do
                CONFIG_XX="$MY_CACHED_DIR/config/$item"
                if [ ! -f "$CONFIG_XX" ] ; then
                    fetch $(config_url "$item") --output-path="$CONFIG_XX" || return 1
                    run chmod a+x "$CONFIG_XX" || return 1
                    if [ "$item" = 'config.sub' ] ; then
                        sed_in_place 's/arm64-*/arm64-*|arm64e-*/g' "$CONFIG_XX" || return 1
                    fi
                fi
                run cp -f "$CONFIG_XX" "$file" || return 1
            done
        done
    fi

    echo "$COLOR_PURPLE==>$COLOR_OFF $COLOR_GREEN$SOURCE_DIR/configure ...$COLOR_OFF"

    if "$SOURCE_DIR"/configure \
        --host="$BUILD_FOR_TARGET" \
        --prefix="$ABI_INSTALL_DIR" \
        --disable-option-checking \
        --disable-rpath \
        --disable-debug \
        --disable-nls\
        --enable-largefile \
        --enable-static \
        --enable-shared \
        CC="$CC" \
        CFLAGS="$CFLAGS" \
        CXX="$CXX" \
        CXXFLAGS="$CXXFLAGS" \
        CPP="$CPP" \
        CPPFLAGS="$CPPFLAGS" \
        LDFLAGS="$LDFLAGS" \
        AR="$AR" \
        RANLIB="$RANLIB" \
        PKG_CONFIG="$PKG_CONFIG" \
        PKG_CONFIG_PATH="$PKG_CONFIG_PATH" \
        PKG_CONFIG_LIBDIR="" \
        CC_FOR_BUILD="$CC_FOR_BUILD" \
        $@ ; then
        echo
    else
        if [ -f "$BUILD_DIR/config.log" ] ; then
            run cat "$BUILD_DIR/config.log"
        elif [ -f "$SOURCE_DIR/config.log" ] ; then
            run cat "$SOURCE_DIR/config.log"
        fi
        return 1
    fi

    if [ "$VERBOSE" = 'true' ] ; then
        for Makefile in $(find "$SOURCE_DIR" -name Makefile)
        do
            sed_in_place 's|\t@|\t|g'     "$Makefile" || return 1
            sed_in_place 's|@echo|echo|g' "$Makefile" || return 1
        done
        unset Makefile
    fi

    run make $MAKEFLAGS clean &&
    run make $MAKEFLAGS       &&
    run make $MAKEFLAGS install
}

# https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html#cross-compiling
# https://cmake.org/cmake/help/latest/variable/CMAKE_EXPORT_COMPILE_COMMANDS.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_ROOT_PATH.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_PREFIX_PATH.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_INSTALL_PREFIX.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html
# https://cmake.org/cmake/help/latest/variable/BUILD_SHARED_LIBS.html
# https://cmake.org/cmake/help/latest/command/enable_testing.html?highlight=build_testing
# run in a subshell
cmake() {
    die_if_command_not_found cmake
    die_if_command_not_found  make

    # CMAKE_HOST_SYSTEM_NAME = $(uname -s)
    # CMAKE_HOST_SYSTEM_NAME on msys2 is not Windows
    if [ "$BUILD_MACHINE_OS_TYPE" = 'windows' ] ; then
        sed_in_place 's|elseif(CMAKE_HOST_SYSTEM_NAME STREQUAL Windows)|else()|g' "$ANDROID_NDK_HOME/build/cmake/android.toolchain.cmake"
    fi

    "$CMAKE" \
    -DCMAKE_EXPORT_COMPILE_COMMANDS=ON \
    -DCMAKE_VERBOSE_MAKEFILE=ON \
    -DCMAKE_COLOR_MAKEFILE=ON \
    -DCMAKE_TOOLCHAIN_FILE="$ANDROID_NDK_HOME/build/cmake/android.toolchain.cmake" \
    -DCMAKE_PREFIX_PATH="$MY_INSTALL_DIR" \
    -DCMAKE_FIND_ROOT_PATH="$MY_INSTALL_DIR" \
    -DCMAKE_INSTALL_PREFIX="$ABI_INSTALL_DIR" \
    -DCMAKE_BUILD_TYPE=Release \
    -DCMAKE_C_FLAGS="'$CFLAGS $CPPFLAGS $LDFLAGS'" \
    -DCMAKE_CXX_FLAGS="'$CFLAGS $CPPFLAGS $LDFLAGS'" \
    -DBUILD_SHARED_LIBS=ON \
    -DBUILD_TESTING=OFF \
    -DANDROID_TOOLCHAIN=clang \
    -DANDROID_ABI="$BUILD_FOR_ABI" \
    -DANDROID_PLATFORM="$MIN_SDK_API_LEVEL" \
    -G "Unix Makefiles" \
    -Wno-dev \
    -S "$SOURCE_DIR" \
    -B "$BUILD_DIR" $@ &&
    run make $MAKEFLAGS --directory="$BUILD_DIR" &&
    run make $MAKEFLAGS --directory="$BUILD_DIR" install
}

# https://mesonbuild.com/Cross-compilation.html
# run in a subshell
meson() {
    die_if_command_not_found meson
    die_if_command_not_found ninja

    case $BUILD_FOR_ARCH in
        armv7a)
            HOST_MACHINE_CPU_FAMILY='arm'
            HOST_MACHINE_CPU_NAME="$BUILD_FOR_ARCH"
            ;;
        aarch64)
            HOST_MACHINE_CPU_FAMILY='aarch64'
            HOST_MACHINE_CPU_NAME='armv8a'
            ;;
        i686)
            HOST_MACHINE_CPU_FAMILY='x86'
            HOST_MACHINE_CPU_NAME="$BUILD_FOR_ARCH"
            ;;
        x86_64)
            HOST_MACHINE_CPU_FAMILY='x86_64'
            HOST_MACHINE_CPU_NAME="$BUILD_FOR_ARCH"
            ;;
    esac

    cat >> "$BUILD_DIR/cross-file" <<EOF
[host_machine]
system = 'android'
endian = 'little'
cpu_family = '$HOST_MACHINE_CPU_FAMILY'
cpu = '$HOST_MACHINE_CPU_NAME'

[binaries]
c = '$CC'
cpp = '$CXX'
ar = '$AR'
strip = '$STRIP'
cmake = '$CMAKE'
pkgconfig = '$PKG_CONFIG'

[properties]
c_args = $(to_meson_array $CFLAGS $CPPFLAGS)
c_link_args = $(to_meson_array $LDFLAGS)
cpp_args = $(to_meson_array $CXXFLAGS $CPPFLAGS)
cpp_link_args = $(to_meson_array $LDFLAGS)
EOF
    run "$MESON" setup \
        --prefix="$ABI_INSTALL_DIR" \
        --buildtype=release \
        --backend=ninja \
        --pkg-config-path="$PKG_CONFIG_PATH" \
        --build.pkg-config-path="$PKG_CONFIG_PATH_FOR_BUILD" \
        --cross-file="$BUILD_DIR/cross-file" \
        $@ "$BUILD_DIR" "$SOURCE_DIR" &&
    run ninja -C "$BUILD_DIR" install
}

to_meson_array() {
    RESULT="[''"
    for item in $@
    do
        RESULT="$RESULT, '$item'"
    done
    RESULT="$RESULT]"
    echo "$RESULT"
}

########################################################################

include_stub_getdtablesize() {
    # https://linux.die.net/man/2/getdtablesize
    # https://hg.mozilla.org/mozreview/gecko/rev/038c2fe02074d03a6c34d44f68cb5f078a2472cc#index_header
    if [ "$BUILD_ROUND_NUM" -eq 1 ] ; then
        cat > "$SOURCE_DIR/stub-getdtablesize.c" <<EOF
#ifndef STUB_GETDTABLESIZE_H
#define STUB_GETDTABLESIZE_H

/* sysinfo is defined but not implemented.
 * we may be able to implement it ourselves. */
#define _SYS_SYSINFO_H_

#include <sys/cdefs.h>
#include <sys/resource.h>
#include <linux/kernel.h>
#include <unistd.h>

/* Use this stub version of getdtablesize
 * instead of the one in the header */
__attribute__((unused))
static int stub_getdtablesize(void) {
    struct rlimit r;
    if (getrlimit(RLIMIT_NOFILE, &r) < 0) {
        return sysconf(_SC_OPEN_MAX);
    }
    return r.rlim_cur;
}

#define getdtablesize() stub_getdtablesize()

#if __ANDROID_API__ < 21
#define RTLD_NOLOAD 0
#endif

#define sysinfo(foo) -1

#endif
EOF
    fi
    export CPPFLAGS="$CPPFLAGS -include $SOURCE_DIR/stub-getdtablesize.c"
}

ldd() {
    check_prerequisites

    die_if_package_is_not_installed "$1"
    die_if_abi_____is_not_supported "$2"
    [ -z "$3" ] && die "type is not specified."
    [ -z "$4" ] && die "name is not specified."

    BUILD_FOR_ARCH=$(echo_arch_by_abi "$2")
    BUILD_FOR_TARGET=$(echo_target_by_arch "$BUILD_FOR_ARCH")
    READELF="$(echo_path_of_tool_in_the_toolchain readelf)"

    ldd_recursion() {
        die_if_package_is_not_installed "$1"
        die_if_abi_____is_not_supported "$2"
        [ -z "$3" ] && die "type is not specified."
        [ -z "$4" ] && die "name is not specified."

        FILE_PATH="$MY_INSTALL_DIR/$1/$2/$3/$4"
        [ -f "$FILE_PATH" ] || die "$FILE_PATH not exist."
        echo "$FILE_PATH"

        DLL=$("$READELF" -d "$FILE_PATH" | grep ".so" | sed 's/.*\[\(.*\)\].*/\1/')
        for item in $DLL
        do
            ldd_recursion $(read_ldd_cache $item)
        done
    }

    ldd_recursion "$1" "$2" "$3" "$4"
}

__list_supported_sdk_api_levels() {
    list 21 22 23 24 25 26 27 28 29
}

__list_supported_abis() {
    list armeabi-v7a arm64-v8a x86 x86_64
}

__list_supported_archs() {
    list armv7a aarch64 i686 x86_64
}

__list_supported_targets() {
    for ARCH in $(__list_supported_archs)
    do
        echo_target_by_arch "$ARCH"
    done
}

echo_arch_by_abi() {
    case $1 in
        '')          die  "abi is not specified." ;;
        armeabi-v7a) echo armv7a  ;;
        arm64-v8a)   echo aarch64 ;;
        x86)         echo i686    ;;
        x86_64)      echo x86_64  ;;
    esac
}

echo_target_by_arch() {
    case $1 in
        '')     die   "arch is not specified."   ;;
        armv7a) echo  "armv7a-linux-androideabi" ;;
        *)      echo  "$1-linux-android"         ;;
    esac
}

sudo() {
    if [ "$(whoami)" = 'root' ] ; then
        $@
    else
        command sudo $@
    fi
}

try_to_install_required_tools_via_package_manager_if_needed() {
    for item in $@
    do
        command -v "$item" > /dev/null && continue
        try_to_install_required_tools_via_package_manager "$item"
    done
}

try_to_install_required_tools_via_package_manager() {
    for item in brew apt-get dnf yum zypper pacman
    do
        case $item in
            brew)
                command -v brew > /dev/null && {
                    brew install $@ &&
                    return $?
                }
                ;;
            apt-get)
                command -v apt-get > /dev/null && {
                    sudo apt-get -y update &&
                    sudo apt-get -y install $@ &&
                    return $?
                }
                ;;
            dnf)
                command -v dnf > /dev/null && {
                    sudo dnf -y update &&
                    sudo dnf -y install $@ &&
                    return $?
                }
                ;;
            yum)
                command -v yum > /dev/null && {
                    sudo yum -y update &&
                    sudo yum -y install $@ &&
                    return $?
                }
                ;;
            zypper)
                command -v zypper > /dev/null && {
                    sudo zypper update -y &&
                    sudo zypper install -y $@ &&
                    return $?
                }
                ;;
            pacman)
                command -v pacman > /dev/null && {
                    sudo pacman -Syyuu --noconfirm &&
                    sudo pacman -S     --noconfirm $@ &&
                    return $?
                }
                ;;
        esac
    done
}

list_tools_in_the_toolchain() {
    list cc cxx cpp as ar ranlib ld nm strip size strings objdump objcopy readelf
}

list_flags_used_by_tools_in_the_toolchain() {
    list CFLAGS CXXFLAGS CPPFLAGS LDFLAGS PKG_CONFIG_PATH PKG_CONFIG_LIBDIR
}

echo_path_of_tool_in_the_toolchain() {
    unset TOOL_PATH
    case $1 in
        cc)  TOOL_PATH="$TOOLCHAIN_BIN_DIR/$BUILD_FOR_TARGET$MIN_SDK_API_LEVEL-clang"   ;;
        cxx) TOOL_PATH="$TOOLCHAIN_BIN_DIR/$BUILD_FOR_TARGET$MIN_SDK_API_LEVEL-clang++" ;;
        *)   TOOL_PATH="$TOOLCHAIN_BIN_DIR/$(echo $BUILD_FOR_TARGET | sed 's/armv7a/arm/')-$1"
             if [ "$1" = 'ld' ] && [ ! -f "$TOOL_PATH" ] ; then
                TOOL_PATH="$TOOL_PATH.gold"
             fi
    esac
    die_if_file_is_not_executable "$TOOL_PATH"
    echo "$TOOL_PATH"
}

ndk_version() {
    if   command -v cut  > /dev/null ; then
        grep "Pkg.Revision" "$ANDROID_NDK_HOME/source.properties" | cut -d " " -f3
    elif command -v awk  > /dev/null ; then
        awk -F= '/Pkg.Revision/{print(substr($2, 2))}' "$ANDROID_NDK_HOME/source.properties"
    elif command -v sed  > /dev/null ; then
        grep "Pkg.Revision" "$ANDROID_NDK_HOME/source.properties" | sed  's/Pkg\.Revision = \(.*\).*/\1/'
    elif command -v gsed > /dev/null ; then
        grep "Pkg.Revision" "$ANDROID_NDK_HOME/source.properties" | gsed 's/Pkg\.Revision = \(.*\).*/\1/'
    elif command -v ruby > /dev/null ; then
        ruby <<EOF
File.open(ENV['ANDROID_NDK_HOME'] + '/source.properties', 'r') {|f|
  f.each_line {|lineText|
    if (lineText =~ /Pkg.Revision =.*/)
        puts lineText.gsub('Pkg.Revision = ', '')
    end
  }
  f.close
}
EOF
    elif command -v perl > /dev/null ; then
        perl << EOF
open(DATA, "<$ANDROID_NDK_HOME/source.properties") or die "$ANDROID_NDK_HOME/source.propertiesæ–‡ä»¶æ— æ³•æ‰“å¼€, $!";
while(<DATA>) {
    if ("\$_" =~ m/Pkg.Revision/) {
        print substr("\$_", 15);
    }
}
EOF
    elif command -v node > /dev/null ; then
        node << EOF
const fs = require('fs');

const buffer = fs.readFileSync("$ANDROID_NDK_HOME/source.properties");
if (buffer instanceof Error) {
    console.log(buffer);
    process.exit(1);
}

const text = buffer.toString();
const lines = text.split('\n');
lines.forEach((line, index, lines) => {
    const matched = line.match(/\d+\.\d+\.\d+/);
    if (matched) {
        console.log(matched[0]);
    }
});
EOF
    else
        PYTHON=$(command -v python3) ||
        PYTHON=$(command -v python)  ||
        PYTHON=$(command -v python2)

        if [ -z "$PYTHON" ] ; then
            die "please install GNU CoreUtils."
        else
            "$PYTHON" << EOF
import re;
file = open("$ANDROID_NDK_HOME/source.properties");
lines = file.readlines();
for line in lines:
    if -1 != line.find("Pkg.Revision"):
        print(re.findall("[0-9]{1,2}\.[0-9]{1,2}\.[0-9]{1,7}", line)[0]);
EOF
        fi
    fi
}

ndk_version_major() {
    if   command -v cut > /dev/null ; then
        printf "$ANDROID_NDK_VERSION" | cut -d. -f1
    elif command -v awk > /dev/null ; then
        printf "$ANDROID_NDK_VERSION" | awk -F. '{print $1}'
    elif command -v sed > /dev/null ; then
        printf "$ANDROID_NDK_VERSION" | sed 's/\..*//g'
    else
        die "please install GNU CoreUtils."
    fi
}

is_a_valid_android_ndk_home_dir() {
    [ -d "$1" ] &&
    [ -f "$1/source.properties" ] &&
    [ -f "$1/build/cmake/android.toolchain.cmake" ] &&
    [ -d "$1/toolchains/llvm/prebuilt/$BUILD_MACHINE_OS_TYPE-$BUILD_MACHINE_OS_ARCH" ] &&
    [ -d "$1/toolchains/llvm/prebuilt/$BUILD_MACHINE_OS_TYPE-$BUILD_MACHINE_OS_ARCH/bin" ] &&
    [ -d "$1/toolchains/llvm/prebuilt/$BUILD_MACHINE_OS_TYPE-$BUILD_MACHINE_OS_ARCH/sysroot" ]
}

check_prerequisites() {
    echo

    if [ -n "$ANDROID_NDK_HOME" ] ; then
        if is_a_valid_android_ndk_home_dir "$ANDROID_NDK_HOME" ; then
            echo "you have set the ${COLOR_RED}ANDROID_NDK_HOME${COLOR_OFF} environment variable and point to ${COLOR_GREEN}$ANDROID_NDK_HOME${COLOR_OFF}, this direcotory used as the android ndk home."
        else
            echo "you have set the ${COLOR_RED}ANDROID_NDK_HOME${COLOR_OFF} environment variable and point to ${COLOR_GREEN}$ANDROID_NDK_HOME${COLOR_OFF}, but it is not a valid android ndk home directory."
            unset ANDROID_NDK_HOME
        fi
    fi

    if [ -z "$ANDROID_NDK_HOME" -a -n "$ANDROID_NDK_ROOT" ] ; then
        if is_a_valid_android_ndk_home_dir "$ANDROID_NDK_ROOT" ; then
            echo "you have set the ${COLOR_RED}ANDROID_NDK_ROOT${COLOR_OFF} environment variable and point to ${COLOR_GREEN}$ANDROID_NDK_ROOT${COLOR_OFF}, this direcotory used as the android ndk home."
            export ANDROID_NDK_HOME="$ANDROID_NDK_ROOT"
        else
            echo "you have set the ${COLOR_RED}ANDROID_NDK_ROOT${COLOR_OFF} environment variable and point to ${COLOR_GREEN}$ANDROID_NDK_ROOT${COLOR_OFF}, but it is not a valid android ndk home directory."
        fi
    fi

    # https://developer.android.com/studio/command-line/variables
    if [ -z "$ANDROID_NDK_HOME" -a -n "$ANDROID_HOME" ] ; then
        if is_a_valid_android_ndk_home_dir "$ANDROID_HOME/ndk-bundle" ; then
            echo "you have set the ${COLOR_RED}ANDROID_HOME${COLOR_OFF} environment variable and point to ${COLOR_GREEN}$ANDROID_HOME${COLOR_OFF}, ${COLOR_GREEN}$ANDROID_HOME/ndk-bundle${COLOR_OFF} used as the android ndk home."
            export ANDROID_NDK_HOME="$ANDROID_HOME/ndk-bundle"
        else
            echo "you have set the ${COLOR_RED}ANDROID_HOME${COLOR_OFF} environment variable and point to ${COLOR_GREEN}$ANDROID_HOME${COLOR_OFF}, ${COLOR_GREEN}$ANDROID_HOME/ndk-bundle${COLOR_OFF} direcotory is not exist."
        fi
    fi

    if [ -z "$ANDROID_NDK_HOME" -a -n "$ANDROID_SDK_ROOT" ] ; then
        if is_a_valid_android_ndk_home_dir "$ANDROID_SDK_ROOT/ndk-bundle" ; then
            echo "you have set the ${COLOR_RED}ANDROID_SDK_ROOT${COLOR_OFF} environment variable and point to ${COLOR_GREEN}$ANDROID_SDK_ROOT${COLOR_OFF}, ${COLOR_GREEN}$ANDROID_SDK_ROOT/ndk-bundle${COLOR_OFF} used as the android ndk home."
            export ANDROID_NDK_HOME="$ANDROID_SDK_ROOT/ndk-bundle"
        else
            echo "you have set the ${COLOR_RED}ANDROID_SDK_ROOT${COLOR_OFF} environment variable and point to ${COLOR_GREEN}$ANDROID_SDK_ROOT${COLOR_OFF}, ${COLOR_GREEN}$ANDROID_SDK_ROOT/ndk-bundle${COLOR_OFF} direcotory is not exist."
        fi
    fi

    echo

    [ -z "$ANDROID_NDK_HOME" ] && die "please set and export ANDROID_NDK_HOME=DIR environment variable, then try again!"
    
    TOOLCHAIN_ROOT="$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/$BUILD_MACHINE_OS_TYPE-$BUILD_MACHINE_OS_ARCH"
    TOOLCHAIN_BIN_DIR="$TOOLCHAIN_ROOT/bin"
    SYSROOT="$TOOLCHAIN_ROOT/sysroot"

    ANDROID_NDK_VERSION="$(ndk_version)"
    ANDROID_NDK_VERSION_MAJOR="$(ndk_version_major)"

    # Android NDK version must be r19 or newer.
    if [ "$ANDROID_NDK_VERSION_MAJOR" -lt 19 ] ; then
        die "your installed android-ndk [$ANDROID_NDK_HOME] version is $ANDROID_NDK_VERSION, please update to r19 or newer."
    fi

    export PATH="$ANDROID_NDK_HOME:$PATH"
}

parse_arguments() {
    # https://stackoverflow.com/questions/18476490/what-is-purpose-of-target-arch-variable-in-makefiles
    unset TARGET_ARCH

    # https://developer.android.google.cn/guide/topics/manifest/uses-sdk-element#api-level-table
    unset USER_SPECIFIED_MIN_SDK_API_LEVEL

    unset USER_SPECIFIED_PACKAGE_LIST

    unset DRYRUN
    unset XTRACE
    unset VERBOSE

    unset WORKING_DIR
    unset KEEP_WORKING_DIR
    
    shift
    
    while test -n "$1"
    do
        case "$1" in
            --min-sdk-api-level=[1-9][0-9])
                USER_SPECIFIED_MIN_SDK_API_LEVEL=$(getvalue "$1")
                ;;
            --verbose|-v)
                VERBOSE=true
                ;;
            --xtrace|-x)
                XTRACE=true
                set -x
                ;;
            --dry-run)
                DRYRUN=true
                ;;
            --keep-working-dir)
                KEEP_WORKING_DIR=true
                ;;
            [a-z]*)
                if [ "$1" = 'all' ] ; then
                    USER_SPECIFIED_PACKAGE_LIST="$(__list_available_packages)"
                else
                    if [ -z "$USER_SPECIFIED_PACKAGE_LIST" ] ; then
                        USER_SPECIFIED_PACKAGE_LIST="$1"
                    else
                        USER_SPECIFIED_PACKAGE_LIST="$USER_SPECIFIED_PACKAGE_LIST $1"
                    fi
                fi
                ;;
            *)  die "$1 is a invalid argument."
        esac
        shift
    done

    BUILD_LIST="$(__list_supported_abis)"
}

init() {
    # MY represents this software's
    MY_NAME=ndk-pkg
    MY_VERSION=0.1.0
    MY_HOME_PAGE="https://github.com/leleliu008/$MY_NAME"

    if [ -z "$NDK_PKG_FORMULA_REPO_URL" ] ; then
        MY_FORMULA_REPO_URL="https://github.com/leleliu008/$MY_NAME-formula.git"
    else
        MY_FORMULA_REPO_URL="$NDK_PKG_FORMULA_REPO_URL"
    fi

    if [ -z "$NDK_PKG_HOME_DIR" ] ; then
        MY_HOME_DIR="$HOME/.$MY_NAME"
    else
        MY_HOME_DIR="$NDK_PKG_HOME_DIR"
    fi

    MY_FORMULA_DIR="$MY_HOME_DIR/formula"
    MY_INSTALL_DIR="$MY_HOME_DIR/pkg"
    MY_CACHED_DIR="$MY_HOME_DIR/downloads"
    MY_BOTTLE_DIR="$MY_HOME_DIR/bottles"
    MY_BACKUP_DIR="$MY_HOME_DIR/backup"
    MY_PATCH_DIR="$MY_HOME_DIR/patches"

    if command -v date > /dev/null ; then
        TIMESTAMP_UNIX="$(date +%s)"
    else
        die "command not found: date. please make sure it in PATH."
    fi

    if command -v uname > /dev/null ; then
        BUILD_MACHINE_OS_TYPE="$(tolower "$(uname)")"
        case $BUILD_MACHINE_OS_TYPE in
            msys*|mingw*|cygwin*) BUILD_MACHINE_OS_TYPE=windows
        esac
        BUILD_MACHINE_OS_ARCH="$(uname -m)"
    else
        die "command not found: uname. please make sure it in PATH."
    fi
}

help() {
    cat << EOF
$MY_NAME is a package manager for Android NDK to build C/C++ project.

Usage: $MY_NAME <ACTION> [ARGUMENT...]

ACTION:
    help    | --help    | -h    --show help information.
    version | --version | -V    --print version of $MY_NAME and Android NDK.
    
    list supported-abis              --list the supported abis.
    list supported-sdk-api-levels    --list the supported android-sdk api-levels.
    
    list available         --list the available packages.
    list installed         --list the installed packages.
    list outdated          --list the outdated packages.

    is available PACKAGE  --is PACKAGE available?
    is installed PACKAGE  --is PACKAGE installed?
    is outdated  PACKAGE  --is PACKAGE outdated?
    
    search KEYWORD        --search packages.
    
    formula create PACKAGE   --create a new formula.
    formula delete PACKAGE   --delete a exist formula.
    formula rename P1 P2     --rename a exist formula to new name.
    formula view PACKAGE     --view the formula of a package.
    formula edit PACKAGE     --edit the formula of a package.
    formula list             --equipment to list available

    tree PACKAGE          --list contents of a installed package directory in a tree-like format.
    pack PACKAGE          --pack a installed package.
    logs PACKAGE ABI      --print the logs of a installed package.
    info PACKAGE...       --print the information of packages.
    fetch PACKAGE         --download formula resources of a package to the cache.
    prefix PACKAGE        --show the installation direcotory of a formula or the $MY_NAME home.
    homepage PACKAGE      --visit the homepage of a formula or the $MY_NAME project.

    install   PACKAGE... [--min-sdk-api-level=21 -v -x --dry-run]     --install packages.
    reinstall PACKAGE... [--min-sdk-api-level=21 -v -x --dry-run]     --reinstall packages.
    upgrade   PACKAGE... [--min-sdk-api-level=21 -v -x --dry-run]     --upgrade packages.
    uninstall PACKAGE...   --uninstall packages.
    
    cleanup          --cleanup the unused cache.
    update           --update the formula repository.
EOF
    if [ -z "$1" ] ; then
        exit
    else
        exit "$1"
    fi
}

main() {
    init

    case $1 in
        --help|help|-h) 
            help
            ;;
        --version|version|-V)
            echo "$MY_VERSION"
            ;;
        version-ndk)
            check_prerequisites
            echo "$ANDROID_NDK_VERSION"
            ;;
        list)
            shift
            case $1 in
                available) shift; __list_available_packages ;;
                installed) shift; __list_installed_packages ;;
                outdated)  shift; __list__outdated_packages ;;
                notdepended) shift; __list_packages_which_is_not_depended_by_others ;;
                archs)     shift; __list_supported_archs ;;
                abis)      shift; __list_supported_abis ;;
                sdk-api-levels)
                           shift; __list_supported_sdk_api_levels ;;
                *) help 1
            esac
            ;;
        search)  shift; __search_packages "$*" ;;
        formula) shift
            case $1 in
                create) shift; __create_a_formula "$@" ;;
                delete) shift; __delete_a_formula "$@" ;;
                rename) shift; __rename_a_formula "$@" ;;
                view)   shift; ____view_a_formula "$@" ;;
                edit)   shift; ____edit_a_formula "$@" ;;
                list)   shift; __list_available_packages ;;
                   *)   help 1
            esac
            ;;
        update)  __update_formula_repository ;;
        cleanup) __cleanup ;;

        install)   ____install_packages "$@" ;;
        reinstall) __reinstall_packages "$@" ;;
        uninstall) __uninstall_packages "$@" ;;
        upgrade)   ____upgrade_packages "$@" ;;

        homepage) shift; __show_webpage_of_a_package    "$@" ;;
        depends)  shift; __show_depends_of_a_package    "$@" ;;
        prefix)   shift; __show_prefix_of_a_package     "$@" ;;
        fetch)    shift; __fetch_resources_of_a_package "$@" ;;
        logs)     shift; __show_logs_of_a_package       "$@" ;;
        pack)     shift; __pack_bottle_of_a_package     "$@" ;;
        tree)     shift; __tree_installed_of_a_package  "$@" ;;
        info)     shift; __show_infomation_of_packages  "$@" ;;
        is)
            shift
            case $1 in
                available) shift; is_package_available "$@" ;;
                installed) shift; is_package_installed "$@" ;;
                outdated)  shift; is_package__outdated "$@" ;;
                *) help 1
            esac
            ;;
        ldd) shift; ldd "$@" ;;
        *) help 1
    esac
}

main "$@"